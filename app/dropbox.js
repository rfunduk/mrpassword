// Generated by CoffeeScript 1.9.2
(function() {
  var AwaitResponse, AwaitResponseDeltas, Backoff, Change, ChangeTransformer, ConsumptionQueue, CreateDatastoreResponse, DEFAULT_DATASTORE_ID, DROPBOX_JS_VERSION, DatastoreModel, DbxClient, DbxEnvGlobal, DbxEnvRequire, DbxXhrArrayBufferView, DbxXhrCanSendForms, DbxXhrDoesPreflight, DbxXhrIeMode, DbxXhrRequest, DbxXhrSendArrayBufferView, DbxXhrWrapBlob, DefaultResolver, DeleteDatastoreResponse, Delta, Dropbox, EventManager, FakeUpdateManager, FieldOp, FieldOpTransformer, FlobClient, GetDatastoreResponse, GetDeltasResponse, GetSnapshotResponse, GetSnapshotResponseRow, ListDatastoresResponse, ListDatastoresResponseItem, LocalDelta, ManagedDatastore, NONCE_LENGTH, NONCE_VALUE_SIZE, ObjectManager, PendingPoll, PutDeltaResponse, REQUEST_ID_HEADER, RecordCache, RecordModel, RecordsChanged, RetryWithBackoff, StructField, SyncQueue, SyncState, T, TableModel, USER_AGENT_PARAM, assert, impl, struct,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    slice = [].slice;

  Dropbox = (function() {
    function Dropbox() {
      throw new Error("Not implemented. Did you mean to use Dropbox.Client?");
    }

    return Dropbox;

  })();

  Dropbox.Util = (function() {
    function Util() {}

    return Util;

  })();

  Dropbox.Http = (function() {
    function Http() {}

    return Http;

  })();

  Dropbox.File = (function() {
    function File() {}

    return File;

  })();

  DROPBOX_JS_VERSION = 'devel';

  if (typeof global !== 'undefined' && typeof module !== 'undefined' && 'exports' in module) {
    DbxEnvGlobal = global;
    DbxEnvRequire = module.require.bind(module);
    module.exports = Dropbox;
  } else if (typeof window !== 'undefined' && typeof navigator !== 'undefined') {
    DbxEnvGlobal = window;
    DbxEnvRequire = null;
    if (window.Dropbox) {
      (function() {
        var name, ref, results1, value;
        ref = window.Dropbox;
        results1 = [];
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          value = ref[name];
          results1.push(Dropbox[name] = value);
        }
        return results1;
      })();
    }
    window.Dropbox = Dropbox;
  } else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
    DbxEnvGlobal = self;
    DbxEnvRequire = self.importScripts.bind(self);
    self.Dropbox = Dropbox;
  } else {
    throw new Error('dropbox.js loaded in an unsupported JavaScript environment.');
  }

  Dropbox.Env = (function() {
    function Env() {}

    Env.global = DbxEnvGlobal;

    Env.require = DbxEnvRequire;

    return Env;

  })();

  Dropbox.Util.EventSource = (function() {
    function EventSource(options) {
      this._cancelable = options && options.cancelable;
      this._listeners = [];
    }

    EventSource.prototype.addListener = function(listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('Invalid listener type; expected function');
      }
      if (indexOf.call(this._listeners, listener) < 0) {
        this._listeners.push(listener);
      }
      return this;
    };

    EventSource.prototype.removeListener = function(listener) {
      var i, index, l, len1, ref, subscriber;
      if (this._listeners.indexOf) {
        index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      } else {
        ref = this._listeners;
        for (i = l = 0, len1 = ref.length; l < len1; i = ++l) {
          subscriber = ref[i];
          if (subscriber === listener) {
            this._listeners.splice(i, 1);
            break;
          }
        }
      }
      return this;
    };

    EventSource.prototype.dispatch = function(event) {
      var l, len1, listener, ref, returnValue;
      ref = this._listeners;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        listener = ref[l];
        returnValue = listener(event);
        if (this._cancelable && returnValue === false) {
          return false;
        }
      }
      return true;
    };

    return EventSource;

  })();

  Dropbox.AccountInfo = (function() {
    AccountInfo.parse = function(accountInfo) {
      if (accountInfo && typeof accountInfo === 'object') {
        return new Dropbox.AccountInfo(accountInfo);
      } else {
        return accountInfo;
      }
    };

    AccountInfo.prototype.name = null;

    AccountInfo.prototype.email = null;

    AccountInfo.prototype.countryCode = null;

    AccountInfo.prototype.uid = null;

    AccountInfo.prototype.referralUrl = null;

    AccountInfo.prototype.publicAppUrl = null;

    AccountInfo.prototype.quota = null;

    AccountInfo.prototype.usedQuota = null;

    AccountInfo.prototype.privateBytes = null;

    AccountInfo.prototype.sharedBytes = null;

    AccountInfo.prototype.json = function() {
      return this._json;
    };

    function AccountInfo(accountInfo) {
      var lastIndex;
      this._json = accountInfo;
      this.name = accountInfo.display_name;
      this.email = accountInfo.email;
      this.countryCode = accountInfo.country || null;
      this.uid = accountInfo.uid.toString();
      if (accountInfo.public_app_url) {
        this.publicAppUrl = accountInfo.public_app_url;
        lastIndex = this.publicAppUrl.length - 1;
        if (lastIndex >= 0 && this.publicAppUrl.substring(lastIndex) === '/') {
          this.publicAppUrl = this.publicAppUrl.substring(0, lastIndex);
        }
      } else {
        this.publicAppUrl = null;
      }
      this.referralUrl = accountInfo.referral_link;
      this.quota = accountInfo.quota_info.quota;
      this.privateBytes = accountInfo.quota_info.normal || 0;
      this.sharedBytes = accountInfo.quota_info.shared || 0;
      this.usedQuota = this.privateBytes + this.sharedBytes;
    }

    return AccountInfo;

  })();

  Dropbox.ApiError = (function() {
    ApiError.prototype.status = null;

    ApiError.prototype.method = null;

    ApiError.prototype.url = null;

    ApiError.prototype.responseText = null;

    ApiError.prototype.response = null;

    ApiError.NETWORK_ERROR = 0;

    ApiError.NO_CONTENT = 304;

    ApiError.INVALID_PARAM = 400;

    ApiError.INVALID_TOKEN = 401;

    ApiError.OAUTH_ERROR = 403;

    ApiError.NOT_FOUND = 404;

    ApiError.INVALID_METHOD = 405;

    ApiError.NOT_ACCEPTABLE = 406;

    ApiError.CONFLICT = 409;

    ApiError.RATE_LIMITED = 429;

    ApiError.SERVER_ERROR = 503;

    ApiError.OVER_QUOTA = 507;

    function ApiError(xhr, method1, url1) {
      var text, xhrError;
      this.method = method1;
      this.url = url1;
      this.status = xhr.status;
      if (xhr.responseType) {
        try {
          text = xhr.response || xhr.responseText;
        } catch (_error) {
          xhrError = _error;
          try {
            text = xhr.responseText;
          } catch (_error) {
            xhrError = _error;
            text = null;
          }
        }
      } else {
        try {
          text = xhr.responseText;
        } catch (_error) {
          xhrError = _error;
          text = null;
        }
      }
      if (text) {
        try {
          this.responseText = text.toString();
          this.response = JSON.parse(text);
        } catch (_error) {
          xhrError = _error;
          this.response = null;
        }
      } else {
        this.responseText = '(no response)';
        this.response = null;
      }
    }

    ApiError.prototype.toString = function() {
      return "Dropbox API error " + this.status + " from " + this.method + " " + this.url + " :: " + this.responseText;
    };

    ApiError.prototype.inspect = function() {
      return this.toString();
    };

    return ApiError;

  })();

  Dropbox.AuthDriver = (function() {
    function AuthDriver() {}

    AuthDriver.prototype.authType = function() {
      return "code";
    };

    AuthDriver.prototype.url = function() {
      return "https://some.url";
    };

    AuthDriver.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      return callback({
        code: 'access-code'
      });
    };

    AuthDriver.prototype.getStateParam = function(client, callback) {
      return callback(Dropbox.Util.Oauth.randomAuthStateParam());
    };

    AuthDriver.prototype.resumeAuthorize = function(stateParam, client, callback) {
      return callback({
        code: 'access-code'
      });
    };

    AuthDriver.prototype.onAuthStateChange = function(client, callback) {
      return callback();
    };

    AuthDriver.oauthQueryParams = ['access_token', 'expires_in', 'scope', 'token_type', 'code', 'error', 'error_description', 'error_uri', 'mac_key', 'mac_algorithm'].sort();

    return AuthDriver;

  })();

  Dropbox.AuthDriver.autoConfigure = function(client) {
    if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
      if (chrome.tabs && chrome.tabs.create) {
        client.authDriver(new Dropbox.AuthDriver.ChromeExtension());
      } else {
        client.authDriver(new Dropbox.AuthDriver.ChromeApp());
      }
      return;
    }
    if (typeof window !== 'undefined') {
      if (window.cordova) {
        client.authDriver(new Dropbox.AuthDriver.Cordova());
        return;
      }
      if (window && window.navigator) {
        client.authDriver(new Dropbox.AuthDriver.Redirect());
      }
    }
  };

  Dropbox.AuthDriver.BrowserBase = (function() {
    function BrowserBase(options) {
      if (options) {
        this.rememberUser = 'rememberUser' in options ? options.rememberUser : true;
        this.scope = options.scope || 'default';
      } else {
        this.rememberUser = true;
        this.scope = 'default';
      }
      this.storageKey = null;
      this.storage = Dropbox.AuthDriver.BrowserBase.localStorage();
      this.stateRe = /^[^#]+\#(.*&)?state=([^&]+)(&|$)/;
    }

    BrowserBase.prototype.authType = function() {
      return 'token';
    };

    BrowserBase.prototype.onAuthStepChange = function(client, callback) {
      this.setStorageKey(client);
      switch (client.authStep) {
        case Dropbox.Client.RESET:
          return this.loadCredentials((function(_this) {
            return function(credentials) {
              if (!credentials) {
                return callback();
              }
              client.setCredentials(credentials);
              if (client.authStep !== Dropbox.Client.DONE) {
                return callback();
              }
              if (!_this.rememberUser) {
                return _this.forgetCredentials(callback);
              }
              client.setCredentials(credentials);
              return callback();
            };
          })(this));
        case Dropbox.Client.DONE:
          if (this.rememberUser) {
            return this.storeCredentials(client.credentials(), callback);
          }
          return this.forgetCredentials(callback);
        case Dropbox.Client.SIGNED_OUT:
          return this.forgetCredentials(callback);
        case Dropbox.Client.ERROR:
          return this.forgetCredentials(callback);
        default:
          callback();
          return this;
      }
    };

    BrowserBase.prototype.setStorageKey = function(client) {
      this.storageKey = "dropbox-auth:" + this.scope + ":" + (client.appHash());
      return this;
    };

    BrowserBase.prototype.storeCredentials = function(credentials, callback) {
      var jsonString, name, storageError, value;
      jsonString = JSON.stringify(credentials);
      try {
        this.storage.setItem(this.storageKey, jsonString);
      } catch (_error) {
        storageError = _error;
        name = encodeURIComponent(this.storageKey);
        value = encodeURIComponent(jsonString);
        document.cookie = name + "=" + value + "; path=/";
      }
      callback();
      return this;
    };

    BrowserBase.prototype.loadCredentials = function(callback) {
      var cookieRegexp, jsonError, jsonString, match, name, nameRegexp, storageError;
      try {
        jsonString = this.storage.getItem(this.storageKey);
      } catch (_error) {
        storageError = _error;
        jsonString = null;
      }
      if (jsonString === null) {
        name = encodeURIComponent(this.storageKey);
        nameRegexp = name.replace(/[.*+()]/g, '\\$&');
        cookieRegexp = new RegExp("(^|(;\\s*))" + name + "=([^;]*)(;|$)");
        if (match = cookieRegexp.exec(document.cookie)) {
          jsonString = decodeURIComponent(match[3]);
        }
      }
      if (!jsonString) {
        callback(null);
        return this;
      }
      try {
        callback(JSON.parse(jsonString));
      } catch (_error) {
        jsonError = _error;
        callback(null);
      }
      return this;
    };

    BrowserBase.prototype.forgetCredentials = function(callback) {
      var expires, name, storageError;
      try {
        this.storage.removeItem(this.storageKey);
      } catch (_error) {
        storageError = _error;
        name = encodeURIComponent(this.storageKey);
        expires = (new Date(0)).toGMTString();
        document.cookie = name + "={}; expires=" + expires + "; path=/";
      }
      callback();
      return this;
    };

    BrowserBase.prototype.locationStateParam = function(url) {
      var location, match;
      location = url || Dropbox.AuthDriver.BrowserBase.currentLocation();
      match = this.stateRe.exec(location);
      if (match) {
        return decodeURIComponent(match[2]);
      }
      return null;
    };

    BrowserBase.prototype.replaceUrlBasename = function(url, basename) {
      var fragments, hashIndex, queryIndex;
      hashIndex = url.indexOf('#');
      if (hashIndex !== -1) {
        url = url.substring(0, hashIndex);
      }
      queryIndex = url.indexOf('?');
      if (queryIndex !== -1) {
        url = url.substring(0, queryIndex);
      }
      fragments = url.split('/');
      fragments[fragments.length - 1] = basename;
      return fragments.join('/');
    };

    BrowserBase.localStorage = function() {
      if (typeof window !== 'undefined') {
        return window.localStorage;
      } else {
        return null;
      }
    };

    BrowserBase.currentLocation = function() {
      return window.location.href;
    };

    BrowserBase.cleanupLocation = function() {
      var hashIndex, pageUrl;
      if (window.history && window.history.replaceState) {
        pageUrl = this.currentLocation();
        hashIndex = pageUrl.indexOf('#');
        window.history.replaceState({}, document.title, pageUrl.substring(0, hashIndex));
      } else {
        window.location.hash = '';
      }
    };

    return BrowserBase;

  })();

  Dropbox.AuthDriver.Redirect = (function(superClass) {
    extend(Redirect, superClass);

    function Redirect(options) {
      Redirect.__super__.constructor.call(this, options);
      this.receiverUrl = this.baseUrl(options);
    }

    Redirect.prototype.baseUrl = function(options) {
      var hashIndex, url;
      url = Dropbox.AuthDriver.BrowserBase.currentLocation();
      if (options) {
        if (options.redirectUrl) {
          return options.redirectUrl;
        }
        if (options.redirectFile) {
          return this.replaceUrlBasename(url, options.redirectFile);
        }
      }
      hashIndex = url.indexOf('#');
      if (hashIndex !== -1) {
        url = url.substring(0, hashIndex);
      }
      return url;
    };

    Redirect.prototype.url = function() {
      return this.receiverUrl;
    };

    Redirect.prototype.doAuthorize = function(authUrl, stateParam, client) {
      return this.storeCredentials(client.credentials(), function() {
        return window.location.assign(authUrl);
      });
    };

    Redirect.prototype.resumeAuthorize = function(stateParam, client, callback) {
      var pageUrl;
      if (this.locationStateParam() === stateParam) {
        pageUrl = Dropbox.AuthDriver.BrowserBase.currentLocation();
        Dropbox.AuthDriver.BrowserBase.cleanupLocation();
        return callback(Dropbox.Util.Oauth.queryParamsFromUrl(pageUrl));
      } else {
        return this.forgetCredentials(function() {
          return callback({
            error: 'Authorization error'
          });
        });
      }
    };

    return Redirect;

  })(Dropbox.AuthDriver.BrowserBase);

  Dropbox.AuthDriver.Popup = (function(superClass) {
    extend(Popup, superClass);

    function Popup(options) {
      Popup.__super__.constructor.call(this, options);
      this.receiverUrl = this.baseUrl(options);
    }

    Popup.prototype.url = function() {
      return this.receiverUrl;
    };

    Popup.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      this.listenForMessage(stateParam, callback);
      return this.openWindow(authUrl);
    };

    Popup.prototype.baseUrl = function(options) {
      var url;
      url = Dropbox.AuthDriver.BrowserBase.currentLocation();
      if (options) {
        if (options.receiverUrl) {
          return options.receiverUrl;
        } else if (options.receiverFile) {
          return this.replaceUrlBasename(url, options.receiverFile);
        }
      }
      return url;
    };

    Popup.prototype.openWindow = function(url) {
      return window.open(url, '_dropboxOauthSigninWindow', this.popupWindowSpec(980, 700));
    };

    Popup.prototype.popupWindowSpec = function(popupWidth, popupHeight) {
      var height, popupLeft, popupTop, ref, ref1, ref2, ref3, width, x0, y0;
      x0 = (ref = window.screenX) != null ? ref : window.screenLeft;
      y0 = (ref1 = window.screenY) != null ? ref1 : window.screenTop;
      width = (ref2 = window.outerWidth) != null ? ref2 : document.documentElement.clientWidth;
      height = (ref3 = window.outerHeight) != null ? ref3 : document.documentElement.clientHeight;
      popupLeft = Math.round(x0 + (width - popupWidth) / 2);
      popupTop = Math.round(y0 + (height - popupHeight) / 2.5);
      if (popupLeft < x0) {
        popupLeft = x0;
      }
      if (popupTop < y0) {
        popupTop = y0;
      }
      return ("width=" + popupWidth + ",height=" + popupHeight + ",") + ("left=" + popupLeft + ",top=" + popupTop) + 'dialog=yes,dependent=yes,scrollbars=yes,location=yes';
    };

    Popup.prototype.listenForMessage = function(stateParam, callback) {
      var listener;
      listener = (function(_this) {
        return function(event) {
          var data, jsonError, oauthInfo;
          if (event.data) {
            data = event.data;
          } else {
            data = event;
          }
          try {
            oauthInfo = JSON.parse(data)._dropboxjs_oauth_info;
          } catch (_error) {
            jsonError = _error;
            return;
          }
          if (!oauthInfo) {
            return;
          }
          if (_this.locationStateParam(oauthInfo) === stateParam) {
            stateParam = false;
            window.removeEventListener('message', listener);
            Dropbox.AuthDriver.Popup.onMessage.removeListener(listener);
            return callback(Dropbox.Util.Oauth.queryParamsFromUrl(data));
          }
        };
      })(this);
      window.addEventListener('message', listener, false);
      return Dropbox.AuthDriver.Popup.onMessage.addListener(listener);
    };

    Popup.locationOrigin = function(location) {
      var match;
      match = /^(file:\/\/[^\?\#]*)(\?|\#|$)/.exec(location);
      if (match) {
        return match[1];
      }
      match = /^([^\:]+\:\/\/[^\/\?\#]*)(\/|\?|\#|$)/.exec(location);
      if (match) {
        return match[1];
      }
      return location;
    };

    Popup.oauthReceiver = function() {
      window.addEventListener('load', function() {
        var frameError, ieError, message, opener, pageOrigin, pageUrl;
        pageUrl = window.location.href;
        message = JSON.stringify({
          _dropboxjs_oauth_info: pageUrl
        });
        Dropbox.AuthDriver.BrowserBase.cleanupLocation();
        opener = window.opener;
        if (window.parent !== window.top) {
          opener || (opener = window.parent);
        }
        if (opener) {
          try {
            pageOrigin = window.location.origin || locationOrigin(pageUrl);
            opener.postMessage(message, pageOrigin);
            window.close();
          } catch (_error) {
            ieError = _error;
          }
          try {
            opener.Dropbox.AuthDriver.Popup.onMessage.dispatch(message);
            return window.close();
          } catch (_error) {
            frameError = _error;
          }
        }
      });
    };

    Popup.onMessage = new Dropbox.Util.EventSource;

    return Popup;

  })(Dropbox.AuthDriver.BrowserBase);

  Dropbox.AuthDriver.ChromeBase = (function(superClass) {
    extend(ChromeBase, superClass);

    function ChromeBase(options) {
      ChromeBase.__super__.constructor.call(this, options);
      this.storageKey = "dropbox_js_" + this.scope + "_credentials";
    }

    ChromeBase.prototype.onAuthStepChange = function(client, callback) {
      switch (client.authStep) {
        case Dropbox.Client.RESET:
          return this.loadCredentials(function(credentials) {
            if (credentials) {
              client.setCredentials(credentials);
            }
            return callback();
          });
        case Dropbox.Client.DONE:
          return this.storeCredentials(client.credentials(), callback);
        case Dropbox.Client.SIGNED_OUT:
          return this.forgetCredentials(callback);
        case Dropbox.Client.ERROR:
          return this.forgetCredentials(callback);
        default:
          return callback();
      }
    };

    ChromeBase.prototype.url = function() {
      return this.receiverUrl;
    };

    ChromeBase.prototype.storeCredentials = function(credentials, callback) {
      var items;
      items = {};
      items[this.storageKey] = credentials;
      chrome.storage.local.set(items, callback);
      return this;
    };

    ChromeBase.prototype.loadCredentials = function(callback) {
      chrome.storage.local.get(this.storageKey, (function(_this) {
        return function(items) {
          return callback(items[_this.storageKey] || null);
        };
      })(this));
      return this;
    };

    ChromeBase.prototype.forgetCredentials = function(callback) {
      chrome.storage.local.remove(this.storageKey, callback);
      return this;
    };

    return ChromeBase;

  })(Dropbox.AuthDriver.BrowserBase);

  Dropbox.AuthDriver.ChromeApp = (function(superClass) {
    extend(ChromeApp, superClass);

    function ChromeApp(options) {
      ChromeApp.__super__.constructor.call(this, options);
      this.receiverUrl = "https://" + chrome.runtime.id + ".chromiumapp.org/";
    }

    ChromeApp.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      return chrome.identity.launchWebAuthFlow({
        url: authUrl,
        interactive: true
      }, (function(_this) {
        return function(redirectUrl) {
          if (_this.locationStateParam(redirectUrl) === stateParam) {
            stateParam = false;
            return callback(Dropbox.Util.Oauth.queryParamsFromUrl(redirectUrl));
          }
        };
      })(this));
    };

    return ChromeApp;

  })(Dropbox.AuthDriver.ChromeBase);

  Dropbox.AuthDriver.ChromeExtension = (function(superClass) {
    extend(ChromeExtension, superClass);

    function ChromeExtension(options) {
      var receiverPath;
      ChromeExtension.__super__.constructor.call(this, options);
      receiverPath = (options && options.receiverPath) || 'chrome_oauth_receiver.html';
      this.receiverUrl = chrome.runtime.getURL(receiverPath);
    }

    ChromeExtension.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      var listener, oauthTab;
      oauthTab = null;
      listener = (function(_this) {
        return function(message, sender) {
          var receiverHref;
          if (sender && sender.tab) {
            if (sender.tab.url.substring(0, _this.receiverUrl.length) !== _this.receiverUrl) {
              return;
            }
          }
          if (!message.dropbox_oauth_receiver_href) {
            return;
          }
          receiverHref = message.dropbox_oauth_receiver_href;
          if (_this.locationStateParam(receiverHref) === stateParam) {
            stateParam = false;
            if (oauthTab) {
              chrome.tabs.remove(oauthTab.id);
            }
            chrome.runtime.onMessage.removeListener(listener);
            return callback(Dropbox.Util.Oauth.queryParamsFromUrl(receiverHref));
          }
        };
      })(this);
      chrome.runtime.onMessage.addListener(listener);
      return chrome.tabs.create({
        url: authUrl,
        active: true,
        pinned: false
      }, function(tab) {
        return oauthTab = tab;
      });
    };

    ChromeExtension.oauthReceiver = function() {
      return window.addEventListener('load', function() {
        var pageUrl;
        pageUrl = window.location.href;
        window.location.hash = '';
        chrome.runtime.sendMessage({
          dropbox_oauth_receiver_href: pageUrl
        });
        if (window.close) {
          return window.close();
        }
      });
    };

    return ChromeExtension;

  })(Dropbox.AuthDriver.ChromeBase);

  Dropbox.AuthDriver.Cordova = (function(superClass) {
    extend(Cordova, superClass);

    function Cordova(options) {
      Cordova.__super__.constructor.call(this, options);
    }

    Cordova.prototype.url = function() {
      return 'https://www.dropbox.com/1/oauth2/redirect_receiver';
    };

    Cordova.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      var authHost, browser, onEvent, promptPageLoaded, removed;
      browser = window.open(authUrl, '_blank', 'location=yes,closebuttoncaption=Cancel');
      promptPageLoaded = false;
      authHost = /^[^\/]*\/\/[^\/]*\//.exec(authUrl)[0];
      removed = false;
      onEvent = (function(_this) {
        return function(event) {
          if (event.url && _this.locationStateParam(event.url) === stateParam) {
            if (removed) {
              return;
            }
            browser.removeEventListener('loadstart', onEvent);
            browser.removeEventListener('loaderror', onEvent);
            browser.removeEventListener('loadstop', onEvent);
            browser.removeEventListener('exit', onEvent);
            removed = true;
            window.setTimeout((function() {
              return browser.close();
            }), 10);
            callback(Dropbox.Util.Oauth.queryParamsFromUrl(event.url));
            return;
          }
          if (event.type === 'exit') {
            if (removed) {
              return;
            }
            browser.removeEventListener('loadstart', onEvent);
            browser.removeEventListener('loaderror', onEvent);
            browser.removeEventListener('loadstop', onEvent);
            browser.removeEventListener('exit', onEvent);
            removed = true;
            callback(new AuthError('error=access_denied&error_description=User+closed+browser+window'));
          }
        };
      })(this);
      browser.addEventListener('loadstart', onEvent);
      browser.addEventListener('loaderror', onEvent);
      browser.addEventListener('loadstop', onEvent);
      return browser.addEventListener('exit', onEvent);
    };

    return Cordova;

  })(Dropbox.AuthDriver.BrowserBase);

  Dropbox.AuthDriver.NodeServer = (function() {
    function NodeServer(options) {
      this._port = (options != null ? options.port : void 0) || 8912;
      if (options != null ? options.tls : void 0) {
        this._tlsOptions = options.tls;
        if (typeof this._tlsOptions === 'string' || this._tlsOptions instanceof Buffer) {
          this._tlsOptions = {
            key: this._tlsOptions,
            cert: this._tlsOptions
          };
        }
      } else {
        this._tlsOptions = null;
      }
      this._fs = Dropbox.Env.require('fs');
      this._http = Dropbox.Env.require('http');
      this._https = Dropbox.Env.require('https');
      this._open = Dropbox.Env.require('open');
      this._callbacks = {};
      this._nodeUrl = Dropbox.Env.require('url');
      this.createApp();
    }

    NodeServer.prototype.authType = function() {
      return "code";
    };

    NodeServer.prototype.url = function() {
      var protocol;
      protocol = this._tlsOptions === null ? 'http' : 'https';
      return protocol + "://localhost:" + this._port + "/oauth_callback";
    };

    NodeServer.prototype.doAuthorize = function(authUrl, stateParam, client, callback) {
      this._callbacks[stateParam] = callback;
      return this.openBrowser(authUrl);
    };

    NodeServer.prototype.openBrowser = function(url) {
      if (!url.match(/^https?:\/\//)) {
        throw new Error("Not a http/https URL: " + url);
      }
      if ('BROWSER' in process.env) {
        return this._open(url, process.env['BROWSER']);
      } else {
        return this._open(url);
      }
    };

    NodeServer.prototype.createApp = function() {
      if (this._tlsOptions) {
        this._app = this._https.createServer(this._tlsOptions, (function(_this) {
          return function(request, response) {
            return _this.doRequest(request, response);
          };
        })(this));
      } else {
        this._app = this._http.createServer((function(_this) {
          return function(request, response) {
            return _this.doRequest(request, response);
          };
        })(this));
      }
      return this._app.listen(this._port);
    };

    NodeServer.prototype.closeServer = function() {
      return this._app.close();
    };

    NodeServer.prototype.doRequest = function(request, response) {
      var data, stateParam, url;
      url = this._nodeUrl.parse(request.url, true);
      if (url.pathname === '/oauth_callback') {
        stateParam = url.query.state;
        if (this._callbacks[stateParam]) {
          this._callbacks[stateParam](url.query);
          delete this._callbacks[stateParam];
        }
      }
      data = '';
      request.on('data', function(dataFragment) {
        return data += dataFragment;
      });
      return request.on('end', (function(_this) {
        return function() {
          return _this.closeBrowser(response);
        };
      })(this));
    };

    NodeServer.prototype.closeBrowser = function(response) {
      var closeHtml;
      closeHtml = "<!doctype html>\n<script type=\"text/javascript\">window.close();</script>\n<p>Please close this window.</p>";
      response.writeHead(200, {
        'Content-Length': closeHtml.length,
        'Content-Type': 'text/html'
      });
      response.write(closeHtml);
      return response.end();
    };

    return NodeServer;

  })();

  Dropbox.AuthError = (function() {
    AuthError.prototype.code = null;

    AuthError.prototype.description = null;

    AuthError.prototype.uri = null;

    AuthError.ACCESS_DENIED = 'access_denied';

    AuthError.INVALID_REQUEST = 'invalid_request';

    AuthError.UNAUTHORIZED_CLIENT = 'unauthorized_client';

    AuthError.INVALID_GRANT = 'invalid_grant';

    AuthError.INVALID_SCOPE = 'invalid_scope';

    AuthError.UNSUPPORTED_GRANT_TYPE = 'unsupported_grant_type';

    AuthError.UNSUPPORTED_RESPONSE_TYPE = 'unsupported_response_type';

    AuthError.SERVER_ERROR = 'server_error';

    AuthError.TEMPORARILY_UNAVAILABLE = 'temporarily_unavailable';

    function AuthError(queryString) {
      var root;
      if (!queryString.error) {
        throw new Error("Not an OAuth 2.0 error: " + (JSON.stringify(queryString)));
      }
      if (typeof queryString.error === 'object' && queryString.error.error) {
        root = queryString.error;
      } else {
        root = queryString;
      }
      this.code = root.error;
      this.description = root.error_description || null;
      this.uri = root.error_uri || null;
    }

    AuthError.prototype.toString = function() {
      return "Dropbox OAuth error " + this.code + " :: " + this.description;
    };

    AuthError.prototype.inspect = function() {
      return this.toString();
    };

    return AuthError;

  })();

  Dropbox.Client = (function() {
    function Client(options) {
      this._serverRoot = options.server || this._defaultServerRoot();
      if ('maxApiServer' in options) {
        this._maxApiServer = options.maxApiServer;
      } else {
        this._maxApiServer = this._defaultMaxApiServer();
      }
      this._authServer = options.authServer || this._defaultAuthServer();
      this._fileServer = options.fileServer || this._defaultFileServer();
      this._downloadServer = options.downloadServer || this._defaultDownloadServer();
      this._notifyServer = options.notifyServer || this._defaultNotifyServer();
      this.onXhr = new Dropbox.Util.EventSource({
        cancelable: true
      });
      this.onError = new Dropbox.Util.EventSource;
      this.onAuthStepChange = new Dropbox.Util.EventSource;
      this._xhrOnErrorHandler = (function(_this) {
        return function(error, callback) {
          return _this._handleXhrError(error, callback);
        };
      })(this);
      this._oauth = new Dropbox.Util.Oauth(options);
      this._uid = options.uid || null;
      this.authStep = this._oauth.step();
      this._driver = null;
      this.authError = null;
      this._credentials = null;
      this._datastoreManager = null;
      this.setupUrls();
    }

    Client.prototype.onXhr = null;

    Client.prototype.onError = null;

    Client.prototype.onAuthStepChange = null;

    Client.prototype.authDriver = function(driver) {
      this._driver = driver;
      return this;
    };

    Client.prototype.dropboxUid = function() {
      return this._uid;
    };

    Client.prototype.credentials = function() {
      if (!this._credentials) {
        this._computeCredentials();
      }
      return this._credentials;
    };

    Client.prototype.authenticate = function(options, callback) {
      var _fsmErrorStep, _fsmNextStep, _fsmStep, interactive, oldAuthStep;
      if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
      }
      if (options && 'interactive' in options) {
        interactive = options.interactive;
      } else {
        interactive = true;
      }
      if (!(this._driver || this.authStep === DbxClient.DONE)) {
        Dropbox.AuthDriver.autoConfigure(this);
        if (!this._driver) {
          throw new Error('OAuth driver auto-configuration failed. Call authDriver.');
        }
      }
      if (this.authStep === DbxClient.ERROR) {
        throw new Error('Client got in an error state. Call reset() to reuse it!');
      }
      _fsmNextStep = (function(_this) {
        return function() {
          _this.authStep = _this._oauth.step();
          if (_this.authStep === DbxClient.ERROR) {
            _this.authError = _this._oauth.error();
          }
          _this._credentials = null;
          _this.onAuthStepChange.dispatch(_this);
          return _fsmStep();
        };
      })(this);
      _fsmErrorStep = (function(_this) {
        return function() {
          _this.authStep = DbxClient.ERROR;
          _this._credentials = null;
          _this.onAuthStepChange.dispatch(_this);
          return _fsmStep();
        };
      })(this);
      oldAuthStep = null;
      _fsmStep = (function(_this) {
        return function() {
          var authUrl;
          if (oldAuthStep !== _this.authStep) {
            oldAuthStep = _this.authStep;
            if (_this._driver && _this._driver.onAuthStepChange) {
              _this._driver.onAuthStepChange(_this, _fsmStep);
              return;
            }
          }
          switch (_this.authStep) {
            case DbxClient.RESET:
              if (!interactive) {
                if (callback) {
                  callback(null, _this);
                }
                return;
              }
              if (_this._driver.getStateParam) {
                _this._driver.getStateParam(function(stateParam) {
                  if (_this.client.authStep === DbxClient.RESET) {
                    _this._oauth.setAuthStateParam(stateParam);
                  }
                  return _fsmNextStep();
                });
              }
              _this._oauth.setAuthStateParam(Dropbox.Util.Oauth.randomAuthStateParam());
              return _fsmNextStep();
            case DbxClient.PARAM_SET:
              if (!interactive) {
                if (callback) {
                  callback(null, _this);
                }
                return;
              }
              authUrl = _this.authorizeUrl();
              return _this._driver.doAuthorize(authUrl, _this._oauth.authStateParam(), _this, function(queryParams) {
                _this._oauth.processRedirectParams(queryParams);
                if (queryParams.uid) {
                  _this._uid = queryParams.uid;
                }
                return _fsmNextStep();
              });
            case DbxClient.PARAM_LOADED:
              if (!_this._driver.resumeAuthorize) {
                _this._oauth.setAuthStateParam(_this._oauth.authStateParam());
                _fsmNextStep();
                return;
              }
              return _this._driver.resumeAuthorize(_this._oauth.authStateParam(), _this, function(queryParams) {
                _this._oauth.processRedirectParams(queryParams);
                if (queryParams.uid) {
                  _this._uid = queryParams.uid;
                }
                return _fsmNextStep();
              });
            case DbxClient.AUTHORIZED:
              return _this.getAccessToken(function(error, data) {
                if (error) {
                  _this.authError = error;
                  return _fsmErrorStep();
                } else {
                  _this._oauth.processRedirectParams(data);
                  _this._uid = data.uid;
                  return _fsmNextStep();
                }
              });
            case DbxClient.DONE:
              if (callback) {
                callback(null, _this);
              }
              break;
            case DbxClient.SIGNED_OUT:
              _this.authStep = DbxClient.RESET;
              _this.reset();
              return _fsmStep();
            case DbxClient.ERROR:
              if (callback) {
                callback(_this.authError, _this);
              }
          }
        };
      })(this);
      _fsmStep();
      return this;
    };

    Client.prototype.isAuthenticated = function() {
      return this.authStep === DbxClient.DONE;
    };

    Client.prototype.signOut = function(options, callback) {
      var stopOnXhrError, xhr;
      if (!callback && typeof options === 'function') {
        callback = options;
        options = null;
      }
      stopOnXhrError = options && options.mustInvalidate;
      if (this.authStep !== DbxClient.DONE) {
        throw new Error("This client doesn't have a user's token");
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.signOut);
      xhr.signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, (function(_this) {
        return function(error) {
          if (error) {
            if (error.status === Dropbox.ApiError.INVALID_TOKEN) {
              error = null;
            } else if (stopOnXhrError) {
              if (callback) {
                callback(error);
              }
              return;
            }
          }
          _this.authStep = DbxClient.RESET;
          _this.reset();
          _this.authStep = DbxClient.SIGNED_OUT;
          _this.onAuthStepChange.dispatch(_this);
          if (_this._driver && _this._driver.onAuthStepChange) {
            return _this._driver.onAuthStepChange(_this, function() {
              if (callback) {
                return callback(null);
              }
            });
          } else {
            if (callback) {
              return callback(null);
            }
          }
        };
      })(this));
    };

    Client.prototype.signOff = function(options, callback) {
      return this.signOut(options, callback);
    };

    Client.prototype.getAccountInfo = function(options, callback) {
      var httpCache, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      httpCache = false;
      if (options && options.httpCache) {
        httpCache = true;
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.accountInfo);
      xhr.signWithOauth(this._oauth, httpCache);
      return this._dispatchXhr(xhr, function(error, accountData) {
        return callback(error, Dropbox.AccountInfo.parse(accountData), accountData);
      });
    };

    Client.prototype.getUserInfo = function(options, callback) {
      return this.getAccountInfo(options, callback);
    };

    Client.prototype.readFile = function(path, options, callback) {
      var httpCache, params, rangeEnd, rangeHeader, rangeStart, responseType, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {};
      responseType = 'text';
      rangeHeader = null;
      httpCache = false;
      if (options) {
        if (options.versionTag) {
          params.rev = options.versionTag;
        } else if (options.rev) {
          params.rev = options.rev;
        }
        if (options.arrayBuffer) {
          responseType = 'arraybuffer';
        } else if (options.blob) {
          responseType = 'blob';
        } else if (options.buffer) {
          responseType = 'buffer';
        } else if (options.binary) {
          responseType = 'b';
        }
        if (options.length) {
          if (options.start != null) {
            rangeStart = options.start;
            rangeEnd = options.start + options.length - 1;
          } else {
            rangeStart = '';
            rangeEnd = options.length;
          }
          rangeHeader = "bytes=" + rangeStart + "-" + rangeEnd;
        } else if (options.start != null) {
          rangeHeader = "bytes=" + options.start + "-";
        }
        if (options.httpCache) {
          httpCache = true;
        }
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.getFile + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth, httpCache);
      xhr.setResponseType(responseType);
      if (rangeHeader) {
        if (rangeHeader) {
          xhr.setHeader('Range', rangeHeader);
        }
        xhr.reportResponseHeaders();
      }
      return this._dispatchXhr(xhr, function(error, data, metadata, headers) {
        var rangeInfo;
        if (headers) {
          rangeInfo = Dropbox.Http.RangeInfo.parse(headers['content-range']);
        } else {
          rangeInfo = null;
        }
        return callback(error, data, Dropbox.File.Stat.parse(metadata), rangeInfo);
      });
    };

    Client.prototype.writeFile = function(path, data, options, callback) {
      var useForm;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      useForm = Dropbox.Util.Xhr.canSendForms && typeof data === 'object';
      if (useForm) {
        return this._writeFileUsingForm(path, data, options, callback);
      } else {
        return this._writeFileUsingPut(path, data, options, callback);
      }
    };

    Client.prototype._writeFileUsingForm = function(path, data, options, callback) {
      var fileName, params, slashIndex, xhr;
      slashIndex = path.lastIndexOf('/');
      if (slashIndex === -1) {
        fileName = path;
        path = '';
      } else {
        fileName = path.substring(slashIndex);
        path = path.substring(0, slashIndex);
      }
      params = {
        file: fileName
      };
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.postFile + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth).setFileField('file', fileName, data, 'application/octet-stream');
      delete params.file;
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype._writeFileUsingPut = function(path, data, options, callback) {
      var params, xhr;
      params = {};
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.putFile + "/" + (this._urlEncodePath(path)));
      xhr.setBody(data).setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.resumableUploadStep = function(data, cursor, callback) {
      var params, xhr;
      if (cursor) {
        params = {
          offset: cursor.offset
        };
        if (cursor.tag) {
          params.upload_id = cursor.tag;
        }
      } else {
        params = {
          offset: 0
        };
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.chunkedUpload);
      xhr.setBody(data).setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, cursor) {
        if (error && error.status === Dropbox.ApiError.INVALID_PARAM && error.response && error.response.upload_id && error.response.offset) {
          return callback(null, Dropbox.Http.UploadCursor.parse(error.response));
        } else {
          return callback(error, Dropbox.Http.UploadCursor.parse(cursor));
        }
      });
    };

    Client.prototype.resumableUploadFinish = function(path, cursor, options, callback) {
      var params, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {
        upload_id: cursor.tag
      };
      if (options) {
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.commitChunkedUpload + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.stat = function(path, options, callback) {
      var httpCache, params, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {};
      httpCache = false;
      if (options) {
        if (options.versionTag) {
          params.rev = options.versionTag;
        } else if (options.rev) {
          params.rev = options.rev;
        }
        if (options.contentHash) {
          params.hash = options.contentHash;
        } else if (options.hash) {
          params.hash = options.hash;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = 'true';
        }
        if (options.readDir) {
          params.list = 'true';
          if (options.readDir !== true) {
            params.file_limit = options.readDir.toString();
          }
        }
        if (options.cacheHash) {
          params.hash = options.cacheHash;
        }
        if (options.httpCache) {
          httpCache = true;
        }
      }
      params.include_deleted || (params.include_deleted = 'false');
      params.list || (params.list = 'false');
      xhr = new Dropbox.Util.Xhr('GET', this._urls.metadata + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth, httpCache);
      return this._dispatchXhr(xhr, function(error, metadata) {
        var entries, entry, stat;
        stat = Dropbox.File.Stat.parse(metadata);
        if (metadata != null ? metadata.contents : void 0) {
          entries = (function() {
            var l, len1, ref, results1;
            ref = metadata.contents;
            results1 = [];
            for (l = 0, len1 = ref.length; l < len1; l++) {
              entry = ref[l];
              results1.push(Dropbox.File.Stat.parse(entry));
            }
            return results1;
          })();
        } else {
          entries = void 0;
        }
        return callback(error, stat, entries);
      });
    };

    Client.prototype.readdir = function(path, options, callback) {
      var statOptions;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      statOptions = {
        readDir: true
      };
      if (options) {
        if (options.limit != null) {
          statOptions.readDir = options.limit;
        }
        if (options.versionTag) {
          statOptions.versionTag = options.versionTag;
        } else if (options.rev) {
          statOptions.versionTag = options.rev;
        }
        if (options.contentHash) {
          statOptions.contentHash = options.contentHash;
        } else if (options.hash) {
          statOptions.contentHash = options.hash;
        }
        if (options.removed || options.deleted) {
          statOptions.removed = options.removed || options.deleted;
        }
        if (options.httpCache) {
          statOptions.httpCache = options.httpCache;
        }
      }
      return this.stat(path, statOptions, function(error, stat, entry_stats) {
        var entries, entry_stat;
        if (entry_stats) {
          entries = (function() {
            var l, len1, results1;
            results1 = [];
            for (l = 0, len1 = entry_stats.length; l < len1; l++) {
              entry_stat = entry_stats[l];
              results1.push(entry_stat.name);
            }
            return results1;
          })();
        } else {
          entries = null;
        }
        return callback(error, entries, stat, entry_stats);
      });
    };

    Client.prototype.metadata = function(path, options, callback) {
      return this.stat(path, options, callback);
    };

    Client.prototype.makeUrl = function(path, options, callback) {
      var isDirect, params, url, useDownloadHack, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      if (options && (options['long'] || options.longUrl || options.downloadHack)) {
        params = {
          short_url: 'false'
        };
      } else {
        params = {};
      }
      path = this._urlEncodePath(path);
      url = this._urls.shares + "/" + path;
      isDirect = false;
      useDownloadHack = false;
      if (options) {
        if (options.downloadHack) {
          isDirect = true;
          useDownloadHack = true;
        } else if (options.download) {
          isDirect = true;
          url = this._urls.media + "/" + path;
        }
      }
      xhr = new Dropbox.Util.Xhr('POST', url).setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, (function(_this) {
        return function(error, urlData) {
          if (useDownloadHack && (urlData != null ? urlData.url : void 0)) {
            urlData.url = urlData.url.replace(_this._authServer, _this._downloadServer);
          }
          return callback(error, Dropbox.File.ShareUrl.parse(urlData, isDirect));
        };
      })(this));
    };

    Client.prototype.history = function(path, options, callback) {
      var httpCache, params, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {};
      httpCache = false;
      if (options) {
        if (options.limit != null) {
          params.rev_limit = options.limit;
        }
        if (options.httpCache) {
          httpCache = true;
        }
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.revisions + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth, httpCache);
      return this._dispatchXhr(xhr, function(error, versions) {
        var metadata, stats;
        if (versions) {
          stats = (function() {
            var l, len1, results1;
            results1 = [];
            for (l = 0, len1 = versions.length; l < len1; l++) {
              metadata = versions[l];
              results1.push(Dropbox.File.Stat.parse(metadata));
            }
            return results1;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.revisions = function(path, options, callback) {
      return this.history(path, options, callback);
    };

    Client.prototype.thumbnailUrl = function(path, options) {
      var xhr;
      xhr = this.thumbnailXhr(path, options);
      return xhr.paramsToUrl().url;
    };

    Client.prototype.readThumbnail = function(path, options, callback) {
      var responseType, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      responseType = 'b';
      if (options) {
        if (options.blob) {
          responseType = 'blob';
        }
        if (options.arrayBuffer) {
          responseType = 'arraybuffer';
        }
        if (options.buffer) {
          responseType = 'buffer';
        }
      }
      xhr = this.thumbnailXhr(path, options);
      xhr.setResponseType(responseType);
      return this._dispatchXhr(xhr, function(error, data, metadata) {
        return callback(error, data, Dropbox.File.Stat.parse(metadata));
      });
    };

    Client.prototype.thumbnailXhr = function(path, options) {
      var params, xhr;
      params = {};
      if (options) {
        if (options.format) {
          params.format = options.format;
        } else if (options.png) {
          params.format = 'png';
        }
        if (options.size) {
          params.size = options.size;
        }
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.thumbnails + "/" + (this._urlEncodePath(path)));
      return xhr.setParams(params).signWithOauth(this._oauth);
    };

    Client.prototype.revertFile = function(path, versionTag, callback) {
      var xhr;
      xhr = new Dropbox.Util.Xhr('POST', this._urls.restore + "/" + (this._urlEncodePath(path)));
      xhr.setParams({
        rev: versionTag
      }).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.restore = function(path, versionTag, callback) {
      return this.revertFile(path, versionTag, callback);
    };

    Client.prototype.findByName = function(path, namePattern, options, callback) {
      var httpCache, params, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {
        query: namePattern
      };
      httpCache = false;
      if (options) {
        if (options.limit != null) {
          params.file_limit = options.limit;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = true;
        }
        if (options.httpCache) {
          httpCache = true;
        }
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.search + "/" + (this._urlEncodePath(path)));
      xhr.setParams(params).signWithOauth(this._oauth, httpCache);
      return this._dispatchXhr(xhr, function(error, results) {
        var metadata, stats;
        if (results) {
          stats = (function() {
            var l, len1, results1;
            results1 = [];
            for (l = 0, len1 = results.length; l < len1; l++) {
              metadata = results[l];
              results1.push(Dropbox.File.Stat.parse(metadata));
            }
            return results1;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.search = function(path, namePattern, options, callback) {
      return this.findByName(path, namePattern, options, callback);
    };

    Client.prototype.makeCopyReference = function(path, callback) {
      var xhr;
      xhr = new Dropbox.Util.Xhr('GET', this._urls.copyRef + "/" + (this._urlEncodePath(path)));
      xhr.signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, refData) {
        return callback(error, Dropbox.File.CopyReference.parse(refData));
      });
    };

    Client.prototype.copyRef = function(path, callback) {
      return this.makeCopyReference(path, callback);
    };

    Client.prototype.pullChanges = function(cursor, callback) {
      var params, xhr;
      if ((!callback) && (typeof cursor === 'function')) {
        callback = cursor;
        cursor = null;
      }
      if (cursor) {
        if (cursor.cursorTag) {
          params = {
            cursor: cursor.cursorTag
          };
        } else {
          params = {
            cursor: cursor
          };
        }
      } else {
        params = {};
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.delta);
      xhr.setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, deltaInfo) {
        return callback(error, Dropbox.Http.PulledChanges.parse(deltaInfo));
      });
    };

    Client.prototype.delta = function(cursor, callback) {
      return this.pullChanges(cursor, callback);
    };

    Client.prototype.pollForChanges = function(cursor, options, callback) {
      var params, xhr;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      if (cursor.cursorTag) {
        params = {
          cursor: cursor.cursorTag
        };
      } else {
        params = {
          cursor: cursor
        };
      }
      if (options && 'timeout' in options) {
        params.timeout = options.timeout;
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.longpollDelta);
      xhr.setParams(params);
      return this._dispatchXhr(xhr, function(error, response) {
        var jsonError;
        if (typeof response === 'string') {
          try {
            response = JSON.parse(response);
          } catch (_error) {
            jsonError = _error;
            response = null;
          }
        }
        return callback(error, Dropbox.Http.PollResult.parse(response));
      });
    };

    Client.prototype.mkdir = function(path, callback) {
      var xhr;
      xhr = new Dropbox.Util.Xhr('POST', this._urls.fileopsCreateFolder);
      xhr.setParams({
        root: 'auto',
        path: this._normalizePath(path)
      }).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.remove = function(path, callback) {
      var xhr;
      xhr = new Dropbox.Util.Xhr('POST', this._urls.fileopsDelete);
      xhr.setParams({
        root: 'auto',
        path: this._normalizePath(path)
      }).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.unlink = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype["delete"] = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype.copy = function(from, toPath, callback) {
      var params, xhr;
      params = {
        root: 'auto',
        to_path: this._normalizePath(toPath)
      };
      if (from instanceof Dropbox.File.CopyReference) {
        params.from_copy_ref = from.tag;
      } else {
        params.from_path = this._normalizePath(from);
      }
      xhr = new Dropbox.Util.Xhr('POST', this._urls.fileopsCopy);
      xhr.setParams(params).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.move = function(fromPath, toPath, callback) {
      var xhr;
      xhr = new Dropbox.Util.Xhr('POST', this._urls.fileopsMove);
      xhr.setParams({
        root: 'auto',
        from_path: this._normalizePath(fromPath),
        to_path: this._normalizePath(toPath)
      }).signWithOauth(this._oauth);
      return this._dispatchXhr(xhr, function(error, metadata) {
        if (callback) {
          return callback(error, Dropbox.File.Stat.parse(metadata));
        }
      });
    };

    Client.prototype.appInfo = function(appKey, callback) {
      var xhr;
      if ((!callback) && (typeof appKey === 'function')) {
        callback = appKey;
        appKey = this._oauth.credentials().key;
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.appsInfo);
      xhr.setParams({
        app_key: appKey
      });
      return this._dispatchXhr(xhr, function(error, appInfo) {
        return callback(error, Dropbox.Http.AppInfo.parse(appInfo, appKey));
      });
    };

    Client.prototype.isAppDeveloper = function(userId, appKey, callback) {
      var xhr;
      if ((typeof userId === 'object') && ('uid' in userId)) {
        userId = userId.uid;
      }
      if ((!callback) && (typeof appKey === 'function')) {
        callback = appKey;
        appKey = this._oauth.credentials().key;
      } else if ((typeof appKey === 'object') && ('key' in appKey)) {
        appKey = appKey.key;
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.appsCheckDeveloper);
      xhr.setParams({
        app_key: appKey,
        uid: userId
      });
      return this._dispatchXhr(xhr, function(error, response) {
        if (response) {
          return callback(error, response.is_developer);
        } else {
          return callback(error);
        }
      });
    };

    Client.prototype.hasOauthRedirectUri = function(redirectUri, appKey, callback) {
      var xhr;
      if ((!callback) && (typeof appKey === 'function')) {
        callback = appKey;
        appKey = this._oauth.credentials().key;
      } else if ((typeof appKey === 'object') && ('key' in appKey)) {
        appKey = appKey.key;
      }
      xhr = new Dropbox.Util.Xhr('GET', this._urls.appsCheckRedirectUri);
      xhr.setParams({
        app_key: appKey,
        redirect_uri: redirectUri
      });
      return this._dispatchXhr(xhr, function(error, response) {
        if (response) {
          return callback(error, response.has_redirect_uri);
        } else {
          return callback(error);
        }
      });
    };

    Client.prototype.reset = function() {
      var oldAuthStep;
      this._uid = null;
      this._oauth.reset();
      oldAuthStep = this.authStep;
      this.authStep = this._oauth.step();
      if (oldAuthStep !== this.authStep) {
        this.onAuthStepChange.dispatch(this);
      }
      this.authError = null;
      this._credentials = null;
      return this;
    };

    Client.prototype.setCredentials = function(credentials) {
      var oldAuthStep;
      oldAuthStep = this.authStep;
      this._oauth.setCredentials(credentials);
      this.authStep = this._oauth.step();
      this._uid = credentials.uid || null;
      this.authError = null;
      this._credentials = null;
      if (oldAuthStep !== this.authStep) {
        this.onAuthStepChange.dispatch(this);
      }
      return this;
    };

    Client.prototype.appHash = function() {
      return this._oauth.appHash();
    };

    Client.prototype.setupUrls = function() {
      this._apiServer = this._chooseApiServer();
      this._urls = {
        authorize: this._authServer + "/1/oauth2/authorize",
        token: this._apiServer + "/1/oauth2/token",
        signOut: this._apiServer + "/1/unlink_access_token",
        accountInfo: this._apiServer + "/1/account/info",
        getFile: this._fileServer + "/1/files/auto",
        postFile: this._fileServer + "/1/files/auto",
        putFile: this._fileServer + "/1/files_put/auto",
        metadata: this._apiServer + "/1/metadata/auto",
        delta: this._apiServer + "/1/delta",
        longpollDelta: this._notifyServer + "/1/longpoll_delta",
        revisions: this._apiServer + "/1/revisions/auto",
        restore: this._apiServer + "/1/restore/auto",
        search: this._apiServer + "/1/search/auto",
        shares: this._apiServer + "/1/shares/auto",
        media: this._apiServer + "/1/media/auto",
        copyRef: this._apiServer + "/1/copy_ref/auto",
        thumbnails: this._fileServer + "/1/thumbnails/auto",
        chunkedUpload: this._fileServer + "/1/chunked_upload",
        commitChunkedUpload: this._fileServer + "/1/commit_chunked_upload/auto",
        fileopsCopy: this._apiServer + "/1/fileops/copy",
        fileopsCreateFolder: this._apiServer + "/1/fileops/create_folder",
        fileopsDelete: this._apiServer + "/1/fileops/delete",
        fileopsMove: this._apiServer + "/1/fileops/move",
        appsInfo: this._apiServer + "/1/apps/info",
        appsCheckDeveloper: this._apiServer + "/1/apps/check_developer",
        appsCheckRedirectUri: this._apiServer + "/1/apps/check_redirect_uri",
        getDb: this._apiServer + "/1/datastores/get_datastore",
        getOrCreateDb: this._apiServer + "/1/datastores/get_or_create_datastore",
        createDb: this._apiServer + "/1/datastores/create_datastore",
        listDbs: this._apiServer + "/1/datastores/list_datastores",
        deleteDb: this._apiServer + "/1/datastores/delete_datastore",
        getSnapshot: this._apiServer + "/1/datastores/get_snapshot",
        getDeltas: this._apiServer + "/1/datastores/get_deltas",
        putDelta: this._apiServer + "/1/datastores/put_delta",
        datastoreAwait: this._apiServer + "/1/datastores/await"
      };
      return this;
    };

    Client.prototype._chooseApiServer = function() {
      var serverId, serverNumber;
      serverNumber = Math.floor(Math.random() * (this._maxApiServer + 1));
      serverId = serverNumber === 0 ? '' : serverNumber.toString();
      return this._serverRoot.replace('$', serverId);
    };

    Client.prototype.authStep = null;

    Client.ERROR = 0;

    Client.RESET = 1;

    Client.PARAM_SET = 2;

    Client.PARAM_LOADED = 3;

    Client.AUTHORIZED = 4;

    Client.DONE = 5;

    Client.SIGNED_OUT = 6;

    Client.prototype._urlEncodePath = function(path) {
      return Dropbox.Util.Xhr.urlEncodeValue(this._normalizePath(path)).replace(/%2F/gi, '/');
    };

    Client.prototype._normalizePath = function(path) {
      var i;
      if (path.substring(0, 1) === '/') {
        i = 1;
        while (path.substring(i, i + 1) === '/') {
          i += 1;
        }
        return path.substring(i);
      } else {
        return path;
      }
    };

    Client.prototype.authorizeUrl = function() {
      var params;
      params = this._oauth.authorizeUrlParams(this._driver.authType(), this._driver.url());
      return this._urls.authorize + "?" + Dropbox.Util.Xhr.urlEncode(params);
    };

    Client.prototype.getAccessToken = function(callback) {
      var params, xhr;
      params = this._oauth.accessTokenParams(this._driver.url());
      xhr = new Dropbox.Util.Xhr('POST', this._urls.token).setParams(params).addOauthParams(this._oauth);
      return this._dispatchXhr(xhr, function(error, data) {
        if (error && error.status === Dropbox.ApiError.INVALID_PARAM && error.response && error.response.error) {
          error = new Dropbox.AuthError(error.response);
        }
        return callback(error, data);
      });
    };

    Client.prototype._dispatchLongPollXhr = function(xhr, callback, expected_time) {
      if (expected_time == null) {
        expected_time = 60000;
      }
      return this._dispatchXhr(xhr, callback, expected_time);
    };

    Client.prototype._dispatchXhr = function(xhr, callback, expected_time) {
      var long_request_timer, nativeXhr;
      if (expected_time == null) {
        expected_time = 10000;
      }
      long_request_timer = setTimeout(((function(_this) {
        return function() {
          return _this._handleLongRequest(xhr);
        };
      })(this)), 2 * expected_time);
      xhr.setCallback((function(_this) {
        return function(error, data, metadata, headers) {
          clearTimeout(long_request_timer);
          return callback(error, data, metadata, headers);
        };
      })(this));
      xhr.onError = this._xhrOnErrorHandler;
      xhr.prepare();
      nativeXhr = xhr.xhr;
      if (this.onXhr.dispatch(xhr)) {
        xhr.send();
      }
      return nativeXhr;
    };

    Client.prototype._handleXhrError = function(error, callback) {
      if (error.status === Dropbox.ApiError.INVALID_TOKEN && this.authStep === DbxClient.DONE) {
        this.authError = error;
        this.authStep = DbxClient.ERROR;
        this.onAuthStepChange.dispatch(this);
        if (this._driver && this._driver.onAuthStepChange) {
          this._driver.onAuthStepChange(this, (function(_this) {
            return function() {
              _this.onError.dispatch(error);
              return callback(error);
            };
          })(this));
          return null;
        }
      }
      this.onError.dispatch(error);
      callback(error);
    };

    Client.prototype._handleLongRequest = function(xhr) {
      return this.setupUrls();
    };

    Client.prototype._defaultServerRoot = function() {
      return 'https://api$.dropbox.com';
    };

    Client.prototype._defaultAuthServer = function() {
      return this._serverRoot.replace('api$', 'www');
    };

    Client.prototype._defaultFileServer = function() {
      return this._serverRoot.replace('api$', 'api-content');
    };

    Client.prototype._defaultDownloadServer = function() {
      return 'https://dl.dropboxusercontent.com';
    };

    Client.prototype._defaultNotifyServer = function() {
      return this._serverRoot.replace('api$', 'api-notify');
    };

    Client.prototype._defaultMaxApiServer = function() {
      return 30;
    };

    Client.prototype._computeCredentials = function() {
      var value;
      value = this._oauth.credentials();
      if (this._uid) {
        value.uid = this._uid;
      }
      if (this._serverRoot !== this._defaultServerRoot()) {
        value.server = this._serverRoot;
      }
      if (this._maxApiServer !== this._defaultMaxApiServer()) {
        value.maxApiServer = this._maxApiServer;
      }
      if (this._authServer !== this._defaultAuthServer()) {
        value.authServer = this._authServer;
      }
      if (this._fileServer !== this._defaultFileServer()) {
        value.fileServer = this._fileServer;
      }
      if (this._downloadServer !== this._defaultDownloadServer()) {
        value.downloadServer = this._downloadServer;
      }
      if (this._notifyServer !== this._defaultNotifyServer()) {
        value.notifyServer = this._notifyServer;
      }
      this._credentials = value;
    };

    return Client;

  })();

  DbxClient = Dropbox.Client;

  Dropbox.Datastore = (function() {
    Datastore.DATASTORE_SIZE_LIMIT = 10 * 1024 * 1024;

    Datastore.RECORD_COUNT_LIMIT = 100000;

    Datastore.BASE_DATASTORE_SIZE = 1000;

    Datastore.TEAM = 'team';

    Datastore.PUBLIC = 'public';

    Datastore.OWNER = 'owner';

    Datastore.EDITOR = 'editor';

    Datastore.VIEWER = 'viewer';

    Datastore.NONE = 'none';

    Datastore.prototype.recordsChanged = null;

    Datastore.prototype.syncStatusChanged = null;

    Datastore.int64 = function(x) {
      var s, y;
      if ((T.is_number(x)) && (x[impl.INT64_TAG] != null)) {
        return impl.validateInt64(x);
      }
      if (T.is_string(x)) {
        if (!impl.is_valid_int64_string(x)) {
          throw new Error("Not a valid int64 in string form: " + x);
        }
        y = new Number(parseInt(x, 10));
        y[impl.INT64_TAG] = x;
        return impl.validateInt64(y);
      }
      if ((!T.is_number(x)) || !isFinite(x)) {
        throw new Error("Not a finite number: " + x);
      }
      if ((Number(x)) !== Math.round(x)) {
        throw new Error("Number is not an integer: " + x);
      }
      s = x.toFixed();
      if (!impl.is_valid_int64_string(s)) {
        throw new Error("Number not in int64 range: " + x);
      }
      y = new Number(x);
      y[impl.INT64_TAG] = s;
      return impl.validateInt64(y);
    };

    Datastore.isInt64 = function(x) {
      return impl.isInt64(x);
    };

    function Datastore(_datastore_manager, _managed_datastore) {
      this._datastore_manager = _datastore_manager;
      this._managed_datastore = _managed_datastore;
      this._dsid = this._managed_datastore.get_dsid();
      this._handle = this._managed_datastore.get_handle();
      this._record_cache = new RecordCache(this);
      this._last_used_timestamp = 0;
      this.recordsChanged = new Dropbox.Util.EventSource;
      this.syncStatusChanged = new Dropbox.Util.EventSource;
      this._timeoutWrapper = function(f) {
        return f;
      };
      this._evt_mgr = new EventManager;
      this._evt_mgr.register(this._managed_datastore.syncStateChanged, (function(_this) {
        return function(e) {
          _this._syncSoon();
          return _this.syncStatusChanged.dispatch(null);
        };
      })(this));
      this._syncPending = false;
      this._closed = false;
      this._metadata_table = new Dropbox.Datastore.Table(this, ':info');
      this._metadata_table.setResolutionRule('mtime', 'max');
    }

    Datastore.prototype.getModifiedTime = function() {
      var metadata_record;
      metadata_record = this._metadata_table.get('info');
      if (metadata_record == null) {
        return null;
      }
      return metadata_record.get('mtime');
    };

    Datastore.prototype.getTitle = function() {
      var metadata_record;
      metadata_record = this._metadata_table.get('info');
      if (metadata_record == null) {
        return null;
      }
      return metadata_record.get('title');
    };

    Datastore.prototype.setTitle = function(title) {
      var metadata_record;
      if (!((title == null) || T.string(title))) {
        throw new Error("Title must be a string or null!");
      }
      metadata_record = this._metadata_table.getOrInsert('info', {});
      return metadata_record.set('title', title);
    };

    Datastore.prototype.isShareable = function() {
      return this._dsid[0] === '.';
    };

    Datastore.prototype._checkShareable = function() {
      if (!this.isShareable()) {
        throw new Error("Datastore is not shareable");
      }
    };

    Datastore.prototype.getEffectiveRole = function() {
      var role;
      if (!this.isShareable()) {
        return Dropbox.Datastore.OWNER;
      }
      role = this._managed_datastore.get_effective_role();
      return Dropbox.Datastore._roleFromInt(role);
    };

    Datastore.prototype.isWritable = function() {
      var role;
      role = this.getEffectiveRole();
      return role === Dropbox.Datastore.OWNER || role === Dropbox.Datastore.EDITOR;
    };

    Datastore.prototype._checkWritable = function() {
      if (!this.isWritable()) {
        throw new Error("Datastore is not writable");
      }
    };

    Datastore.prototype._checkRole = function(role) {
      if (!(role === Dropbox.Datastore.EDITOR || role === Dropbox.Datastore.VIEWER)) {
        throw new Error("Invalid role: " + role);
      }
    };

    Datastore.prototype._checkPrincipal = function(principal) {
      if (!(principal === Dropbox.Datastore.TEAM || principal === Dropbox.Datastore.PUBLIC || principal.match(/^u[1-9][0-9]*$/))) {
        throw new Error("Invalid principal: " + principal);
      }
    };

    Datastore.prototype._getRole = function(principal) {
      var irole, ref, ref1;
      irole = (ref = this.getTable(impl.ACL_TID)) != null ? (ref1 = ref.get(principal)) != null ? ref1.get('role') : void 0 : void 0;
      if (irole == null) {
        return Dropbox.Datastore.NONE;
      }
      return Dropbox.Datastore._roleFromInt(irole);
    };

    Datastore.prototype.getRole = function(principal) {
      this._checkShareable();
      this._checkPrincipal(principal);
      return this._getRole(principal);
    };

    Datastore.prototype.setRole = function(principal, role) {
      var irole;
      if (role === Dropbox.Datastore.NONE) {
        this.deleteRole(principal);
        return;
      }
      this._checkShareable();
      this._checkPrincipal(principal);
      this._checkRole(role);
      this._checkWritable();
      irole = Dropbox.Datastore.int64(Dropbox.Datastore._intFromRole(role));
      return this.getTable(impl.ACL_TID).getOrInsert(principal).update({
        role: irole
      });
    };

    Datastore.prototype.deleteRole = function(principal) {
      var ref;
      this._checkShareable();
      this._checkPrincipal(principal);
      this._checkWritable();
      return (ref = this.getTable(impl.ACL_TID).get(principal)) != null ? ref.deleteRecord() : void 0;
    };

    Datastore.prototype.listRoles = function() {
      var l, len1, principal, record, ref, role_map;
      this._checkShareable();
      role_map = {};
      ref = this.getTable(impl.ACL_TID).query();
      for (l = 0, len1 = ref.length; l < len1; l++) {
        record = ref[l];
        principal = record.getId();
        role_map[principal] = this._getRole(principal);
      }
      return role_map;
    };

    Datastore._roleFromInt = function(irole) {
      switch (false) {
        case !(irole >= impl.ROLE_OWNER):
          return Dropbox.Datastore.OWNER;
        case !(irole >= impl.ROLE_EDITOR):
          return Dropbox.Datastore.EDITOR;
        case !(irole >= impl.ROLE_VIEWER):
          return Dropbox.Datastore.VIEWER;
        default:
          return Dropbox.Datastore.NONE;
      }
    };

    Datastore._intFromRole = function(role) {
      switch (role) {
        case Dropbox.Datastore.OWNER:
          return impl.ROLE_OWNER;
        case Dropbox.Datastore.EDITOR:
          return impl.ROLE_EDITOR;
        case Dropbox.Datastore.VIEWER:
          return impl.ROLE_VIEWER;
        default:
          return 0;
      }
    };

    Datastore.prototype.getTable = function(tableId) {
      this._checkNotClosed();
      if (!Dropbox.Datastore.Table.isValidId(tableId)) {
        throw new Error("Invalid table ID: " + tableId);
      }
      return new Dropbox.Datastore.Table(this, tableId);
    };

    Datastore.prototype.listTableIds = function() {
      this._checkNotClosed();
      return this._managed_datastore.list_tables();
    };

    Datastore.prototype.getRecordCount = function() {
      return this._managed_datastore.get_record_count();
    };

    Datastore.prototype.getSize = function() {
      return this._managed_datastore.get_size();
    };

    Datastore.prototype.toString = function() {
      var closed;
      closed = this._closed ? "[closed] " : "";
      return "Datastore(" + closed + this._dsid + " [" + this._handle + "])";
    };

    Datastore.prototype.close = function() {
      this._closed = true;
      this._evt_mgr.unregister_all();
      this._listeners = [];
      this._datastore_manager._obj_manager.close(this._dsid);
      return void 0;
    };

    Datastore.prototype.getId = function() {
      return this._dsid;
    };

    Datastore.prototype.getSyncStatus = function() {
      return {
        uploading: this._managed_datastore.get_outgoing_delta_count() > 0
      };
    };

    Datastore.isValidId = function(datastoreId) {
      var datastoreIdRe;
      datastoreIdRe = new RegExp(T.DS_ID_REGEX);
      return T.is_string(datastoreId) && datastoreIdRe.test(datastoreId);
    };

    Datastore.isValidShareableId = function(datastoreId) {
      return this.isValidId(datastoreId) && datastoreId[0] === '.';
    };

    Datastore.prototype._generateRid = function() {
      var encoded_timestamp, infix, now, prefix;
      prefix = '_';
      infix = '_js_';
      now = Math.round(Date.now() * 1000);
      if (now <= this._last_used_timestamp) {
        now = this._last_used_timestamp + 1;
      }
      this._last_used_timestamp = now;
      encoded_timestamp = now.toString(32);
      while (encoded_timestamp.length < 11) {
        encoded_timestamp = "0" + encoded_timestamp;
      }
      return prefix + encoded_timestamp + infix + impl.randomWeb64String(5);
    };

    Datastore.prototype._syncSoon = function() {
      if (this._managed_datastore.is_deleted()) {
        throw new Error("Cannot sync deleted datastore " + this._dsid);
      }
      this._checkNotClosed();
      if (!this._syncPending) {
        this._syncPending = true;
        setTimeout(this._timeoutWrapper((function(_this) {
          return function() {
            _this._syncPending = false;
            return _this._sync();
          };
        })(this)), 0);
      }
      return void 0;
    };

    Datastore.prototype._sync = function() {
      var found_something, l, len1, record, records, recordsByTable, remote_affected_record_map, rid, tid;
      this._checkNotClosed();
      remote_affected_record_map = this._managed_datastore.sync();
      recordsByTable = this._resolveAffectedRecordMap(remote_affected_record_map);
      found_something = false;
      for (tid in recordsByTable) {
        records = recordsByTable[tid];
        for (l = 0, len1 = records.length; l < len1; l++) {
          record = records[l];
          assert(tid === record._tid, "tid mismatch");
          found_something = true;
          rid = record._rid;
          if (!this._managed_datastore.query(tid, rid)) {
            record._deleted = true;
            this._record_cache.remove(tid, rid);
          }
        }
      }
      if (found_something) {
        this.recordsChanged.dispatch(new RecordsChanged(recordsByTable, false));
      }
      return void 0;
    };

    Datastore.prototype._resolveAffectedRecordMap = function(m) {
      var record, recordsByTable, rid, rids, tid;
      recordsByTable = {};
      for (tid in m) {
        rids = m[tid];
        for (rid in rids) {
          record = this._record_cache.getOrCreate(tid, rid);
          if (recordsByTable[tid] == null) {
            recordsByTable[tid] = [];
          }
          recordsByTable[tid].push(record);
        }
      }
      return recordsByTable;
    };

    Datastore.prototype._recordsChangedLocally = function(records) {
      if (records.length > 0) {
        this.recordsChanged.dispatch(RecordsChanged._fromRecordList(records, true));
        this._syncSoon();
      }
      return void 0;
    };

    Datastore.prototype._checkNotClosed = function() {
      if (this._closed || !this._managed_datastore._open) {
        throw new Error("Datastore is already closed: " + this);
      }
      return void 0;
    };

    return Datastore;

  })();

  impl = Dropbox.Datastore.impl = {};

  T = Dropbox.Datastore.impl.T = {};

  T.identity = function(x) {
    return x;
  };

  T.get_coerce_fn = function(type) {
    if (type.coerce != null) {
      return type.coerce;
    }
    if (type.load_json != null) {
      return function(x) {
        if (x instanceof type) {
          return x;
        } else {
          return type.load_json(x);
        }
      };
    }
    return T.identity;
  };

  T.get_T_fn = function(type) {
    if (type.Type != null) {
      return type.Type;
    } else {
      return type;
    }
  };

  T.str = function(x) {
    if (T.is_string(x)) {
      return x;
    } else if (T.is_function(x)) {
      return x();
    } else {
      return JSON.stringify(x);
    }
  };

  T.assert = function(c, stringlike) {
    if (!c) {
      throw new Error(T.str(stringlike));
    }
  };

  assert = T.assert;

  T.check = function(c, m, x, what, wanted, top) {
    if (c) {
      return x;
    }
    T.fail(m, x, what, wanted, top);
    throw new Error("unreachable");
  };

  T.safe_to_string = function(x) {
    var e, repr;
    try {
      repr = x.toString();
      if (repr !== "[object Object]") {
        return repr;
      }
    } catch (_error) {
      e = _error;
    }
    try {
      return JSON.stringify(x);
    } catch (_error) {
      e = _error;
    }
    try {
      repr = x.constructor.name;
      if (repr != null ? repr.match(/^[A-Za-z0-9_]+$/) : void 0) {
        return repr;
      }
    } catch (_error) {
      e = _error;
    }
    return '[T.safe_to_string failed]';
  };

  T.fail = function(m, x, what, wanted, top) {
    var e, msg;
    if (false) {
      console.log("m=" + m + " " + (JSON.stringify(m)));
      console.log("x=" + x);
      console.log("x=" + (JSON.stringify(x)));
      console.log("what=" + what + " " + (JSON.stringify(what)));
      console.log("wanted=" + wanted + " " + (JSON.stringify(wanted)));
      console.log("top=" + top + " " + (JSON.stringify(top)));
    }
    if (what != null) {
      if (wanted != null) {
        if (top != null) {
          msg = "Wanted " + (T.str(wanted)) + ", but " + (T.str(what)) + " in " + (T.str(top)) + " " + (T.str(m));
        } else {
          msg = "Wanted " + (T.str(wanted)) + ", but " + (T.str(what)) + " " + (T.str(m));
        }
      } else {
        msg = (T.str(what)) + " " + (T.str(m));
      }
    } else {
      if (wanted != null) {
        if (top != null) {
          msg = "Wanted " + (T.str(wanted)) + ", but in " + (T.str(top)) + " " + (T.str(m));
        } else {
          msg = "Wanted " + (T.str(wanted)) + ", but " + (T.str(m));
        }
      } else {
        msg = "" + (T.str(m));
      }
    }
    e = new Error(msg + ": " + (T.safe_to_string(x)));
    console.error(e);
    if (false) {
      window.alert(e.stack);
    }
    throw e;
  };

  T.any = function(x, what, wanted, top) {
    return x;
  };

  T.defined = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "defined";
    }
    T.check(typeof x !== "undefined", "is undefined", x, what, wanted, top);
    return x;
  };

  T.nonnull = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "nonnull";
    }
    T.defined(x, what, wanted, top);
    T.check(x != null, "is null", x, what, wanted, top);
    return x;
  };

  T.member = function(arr) {
    var msg, w;
    w = "value in " + (JSON.stringify(arr));
    msg = "not in " + (JSON.stringify(arr));
    return function(x, what, wanted, top) {
      if (wanted == null) {
        wanted = w;
      }
      return T.check((indexOf.call(arr, x) >= 0), msg, x, what, wanted, top);
    };
  };

  T.object = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "object";
    }
    T.nonnull(x, what, wanted, top);
    T.check(typeof x === "object", "not an object", x, what, wanted, top);
    return x;
  };

  T.bool = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "bool";
    }
    T.nonnull(x, what, wanted, top);
    T.check(x === true || x === false, "is not bool", x, what, wanted, top);
    return x;
  };

  T.string = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "string";
    }
    T.nonnull(x, what, wanted, top);
    T.check(T.is_string(x), "is not a string", x, what, wanted, top);
    return x;
  };

  T.num = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "num";
    }
    T.nonnull(x, what, wanted, top);
    T.check(typeof x === "number", "is not numeric", x, what, wanted, top);
    return x;
  };

  T.int = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "int";
    }
    T.num(x, what, wanted, top);
    T.check(x % 1 === 0, "is not an integer", x, what, wanted, top);
    return x;
  };

  T.uint = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "uint";
    }
    T.int(x, what, wanted, top);
    T.check(x >= 0, "is negative", x, what, wanted, top);
    return x;
  };

  T.nullable = function(base) {
    var fn, w;
    w = "nullable(" + base + ")";
    fn = function(x, what, wanted, top) {
      if (wanted == null) {
        wanted = function() {
          return w;
        };
      }
      T.defined(x, what, wanted, top);
      if (x != null) {
        T.get_T_fn(base)(x, what, wanted, top);
      }
      return x;
    };
    fn.toString = function() {
      return w;
    };
    fn.coerce = function(x) {
      if (x != null) {
        return T.get_coerce_fn(base)(x);
      } else {
        return null;
      }
    };
    fn.fromJSON = function(x) {
      if (x != null) {
        if (base.fromJSON != null) {
          return base.fromJSON(x);
        } else {
          return fn.coerce(x);
        }
      } else {
        return null;
      }
    };
    return fn;
  };

  T.array = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "array";
    }
    T.nonnull(x, what, wanted, top);
    T.check(T.is_array(x), "is not an array", x, what, wanted, top);
    return x;
  };

  T.arrayOf = function(elementT) {
    var arrayType, w;
    w = "arrayOf(" + elementT + ")";
    arrayType = function(x, what, wanted, top) {
      var elt, eltDescription, i, l, len1;
      if (wanted == null) {
        wanted = w;
      }
      T.array(x, what, wanted, top);
      for (i = l = 0, len1 = x.length; l < len1; i = ++l) {
        elt = x[i];
        eltDescription = function() {
          if (what != null) {
            return "element " + i + " of " + (T.str(what));
          } else {
            return "element " + i;
          }
        };
        T.get_T_fn(elementT)(elt, eltDescription, wanted, top);
      }
      return x;
    };
    arrayType.toString = function() {
      return w;
    };
    arrayType.coerce = function(x) {
      var e, l, len1, results1;
      T.array(x, null, w);
      results1 = [];
      for (l = 0, len1 = x.length; l < len1; l++) {
        e = x[l];
        results1.push(T.get_coerce_fn(elementT)(e));
      }
      return results1;
    };
    arrayType.fromJSON = function(x) {
      var l, len1, results1, y;
      T.array(x, 'fromJSON input', w);
      if (elementT.fromJSON != null) {
        results1 = [];
        for (l = 0, len1 = x.length; l < len1; l++) {
          y = x[l];
          results1.push(elementT.fromJSON(y));
        }
        return results1;
      } else {
        return arrayType.coerce(x);
      }
    };
    return arrayType;
  };

  T.instance = function(x, type, what, wanted, top) {
    var ref;
    if (!(type instanceof Function)) {
      throw new Error('Invalid type given: ' + type);
    }
    if (!(x instanceof type)) {
      if (wanted == null) {
        wanted = type.name;
      }
      T.check(false, "got instance of " + (x != null ? (ref = x.constructor) != null ? ref.name : void 0 : void 0), x, what, wanted, top);
    }
    return x;
  };

  T.unimplemented = function(msg) {
    return function() {
      throw new Error('unimplemented ' + msg);
    };
  };

  T.startsWith = function(s, prefix) {
    return s.lastIndexOf(prefix, 0) === 0;
  };

  T.string_matching = function(regex_pattern_string) {
    var msg;
    T.string(regex_pattern_string);
    T.check(/^[^].*[$]$/.test(regex_pattern_string), "does not start with ^ and end with $", regex_pattern_string);
    msg = "does not match regex " + regex_pattern_string;
    return function(x, what, wanted, top) {
      T.string(x, what, wanted, top);
      T.check((new RegExp(regex_pattern_string)).test(x), msg, x, what, wanted, top);
      return x;
    };
  };

  T.is_defined = function(x) {
    return typeof x !== "undefined";
  };

  T.is_bool = function(x) {
    return x === true || x === false || (x && (typeof x === "object") && x.constructor === Boolean);
  };

  T.is_number = function(x) {
    return (typeof x === "number") || (x && (typeof x === "object") && x.constructor === Number);
  };

  T.is_json_number = function(x) {
    return (T.is_number(x)) && !(isNaN(x)) && isFinite(x);
  };

  T.is_string = function(x) {
    return typeof x === "string" || (x && (typeof x === "object") && x.constructor === String);
  };

  T.is_function = function(x) {
    return typeof x === 'function';
  };

  T.is_object = function(x) {
    return (x != null) && typeof x === 'object';
  };

  T.is_array = function(x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };

  T.is_empty = function(x) {
    return Object.keys(x).length === 0;
  };

  T.is_date = function(x) {
    return Object.prototype.toString.call(x) === '[object Date]';
  };

  T.isUint8Array = function(x) {
    return Object.prototype.toString.call(x) === '[object Uint8Array]';
  };

  T.is_simple_map = function(x) {
    var key, value;
    if ((x == null) || !(typeof x === "object")) {
      return false;
    }
    for (key in x) {
      value = x[key];
      if (!(Object.prototype.hasOwnProperty.call(x, key))) {
        return false;
      }
    }
    return true;
  };

  T.simple_map = function(x, what, wanted, top) {
    var key, value;
    if (wanted == null) {
      wanted = "simple map";
    }
    T.object(x, what, wanted, top);
    for (key in x) {
      value = x[key];
      T.check(Object.prototype.hasOwnProperty.call(x, key), (function() {
        return "property " + key + " is inherited";
      }), x, what, wanted, x);
    }
    return x;
  };

  T.simple_typed_map = function(type_name, key_type, value_type) {
    var coerce_key, coerce_value, type;
    coerce_key = T.get_coerce_fn(key_type);
    coerce_value = T.get_coerce_fn(value_type);
    type = function(x, what, wanted, top) {
      var key, value;
      if (wanted == null) {
        wanted = type_name;
      }
      T.simple_map(x, what, wanted, top);
      for (key in x) {
        value = x[key];
        (T.get_T_fn(key_type))(key, "property", null, x);
        (T.get_T_fn(value_type))(value, (function() {
          return "value of property " + key;
        }), null, x);
      }
      return x;
    };
    type.coerce = function(x) {
      var k, out, v;
      T.simple_map(x, null, type_name);
      out = {};
      for (k in x) {
        v = x[k];
        out[coerce_key(k)] = coerce_value(v);
      }
      return out;
    };
    type.fromJSON = function(x) {
      var k, out, v;
      T.simple_map(x, null, type_name);
      out = {};
      for (k in x) {
        v = x[k];
        out[coerce_key(k)] = value_type.fromJSON != null ? value_type.fromJSON(v) : v;
      }
      return out;
    };
    return type;
  };

  T.DS_ID_REGEX = "^[-_a-z0-9]([-_a-z0-9.]{0,62}[-_a-z0-9])?$|^[.][-_a-zA-Z0-9]{1,63}$";

  T.dsid = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "dsid";
    }
    (T.string_matching(T.DS_ID_REGEX))(x, what, wanted, top);
    return x;
  };

  T.SS_ID_REGEX = "^[-._+/=a-zA-Z0-9]{1,64}$|^:[-._+/=a-zA-Z0-9]{1,63}$";

  T.tid = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "tid";
    }
    (T.string_matching(T.SS_ID_REGEX))(x, what, wanted, top);
    return x;
  };

  T.rowid = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "rowid";
    }
    (T.string_matching(T.SS_ID_REGEX))(x, what, wanted, top);
    return x;
  };

  T.field_name = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "field name";
    }
    (T.string_matching(T.SS_ID_REGEX))(x, what, wanted, top);
    return x;
  };

  (function() {
    var k, results1, v;
    results1 = [];
    for (k in T) {
      v = T[k];
      if (T.hasOwnProperty(k)) {
        results1.push((function(k) {
          return v.toString = function() {
            return "T." + k;
          };
        })(k));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  })();

  impl.struct = struct = {};

  struct.define = function(stname, fields_arg) {
    var __field_map, __fields, args, clazz, f, field, i, init, initFn, k, l, len1, msg, name, options, type;
    T.string(stname, "struct name");
    T.array(fields_arg, "fields");
    __fields = [];
    __field_map = {};
    for (i = l = 0, len1 = fields_arg.length; l < len1; i = ++l) {
      f = fields_arg[i];
      T.array(f, "field", "field descriptor", fields_arg);
      T.check(2 <= f.length && f.length <= 3, "does not have length 2 or 3", f, "field descriptor");
      name = T.string(f[0], "field name", "field descriptor", fields_arg);
      type = T.nonnull(f[1], "field type", "field descriptor", fields_arg);
      options = f.length <= 2 ? {} : T.nonnull(f[2], "map of field options", "field descriptor", fields_arg);
      for (k in options) {
        if (k !== 'init' && k !== 'initFn') {
          T.fail("unknown option " + k, options, "field options", "field descrptor", fields_arg);
        }
      }
      if (indexOf.call(options, 'init') >= 0 && indexOf.call(options, 'initFn') >= 0) {
        T.fail("both 'init' and 'initFn' specified", options, "field options", "field descriptor", fields_arg);
      }
      initFn = 'initFn' in options ? options.initFn : 'init' in options ? (init = options.init, (function(init) {
        return function() {
          return init;
        };
      })(init)) : null;
      args = {
        name: name,
        type: type,
        initFn: initFn
      };
      if (typeof StructField !== "undefined" && StructField !== null) {
        field = new StructField(args);
      } else {
        field = args;
      }
      __fields.push(field);
      __field_map[name] = field;
    }
    msg = "initializer for " + stname + " (fields " + (((function() {
      var len2, o, results1;
      results1 = [];
      for (o = 0, len2 = __fields.length; o < len2; o++) {
        f = __fields[o];
        results1.push(f.name);
      }
      return results1;
    })()).join(', ')) + ")";
    clazz = function(x) {
      var len2, o, value;
      T.defined(x, "x", "initializer");
      for (name in x) {
        value = x[name];
        if (x.hasOwnProperty(name)) {
          T.check(__field_map[name] != null, (function() {
            return "has an unexpected field " + name;
          }), x, "initializer");
        }
      }
      for (o = 0, len2 = __fields.length; o < len2; o++) {
        field = __fields[o];
        if (x[field.name] && !x.hasOwnProperty(field.name)) {
          T.fail("Has an indirect property " + field.name, x, "initializer");
        }
        if (!x.hasOwnProperty(field.name)) {
          if (field.initFn != null) {
            this[field.name] = field.initFn();
          } else {
            T.fail("lacks the field " + field.name, x, "initializer");
          }
        } else {
          value = x[field.name];
          this[field.name] = T.get_coerce_fn(field.type)(value);
        }
      }
      clazz.Type(this, "initializer", msg, this);
      return this;
    };
    clazz.Type = function(x, what, wanted, top) {
      var len2, o, value;
      T.defined(x, what, wanted, top);
      T.check(x instanceof clazz, (function() {
        return "is not an instance of " + stname;
      }), x, what, wanted, top);
      for (o = 0, len2 = __fields.length; o < len2; o++) {
        field = __fields[o];
        T.check(x.hasOwnProperty(field.name), (function() {
          return "lacks the field " + field.name;
        }), x, what, wanted, top);
        T.get_T_fn(field.type)(x[field.name], field.name, wanted, top);
      }
      for (name in x) {
        value = x[name];
        if (x.hasOwnProperty(name)) {
          T.check(__field_map[name] != null, "has an unexpected field", name, what, wanted, top);
        }
      }
      return x;
    };
    clazz.coerce = function(x) {
      if (x instanceof clazz) {
        clazz.Type(x);
        return x;
      } else {
        return new clazz(x);
      }
    };
    clazz.prototype.toString = function() {
      var data, len2, o, obj, v;
      obj = this;
      data = [];
      for (o = 0, len2 = __fields.length; o < len2; o++) {
        field = __fields[o];
        v = obj[field.name];
        data.push((field.name + ": ") + ((T.is_object(v)) && (T.is_function(v.toString)) ? v.toString() : JSON.stringify(v)));
      }
      return "{" + (data.join(', ')) + "}";
    };
    clazz.prototype.toJSON = function() {
      var len2, o, obj, str;
      obj = this;
      str = function() {
        return "" + obj;
      };
      for (o = 0, len2 = __fields.length; o < len2; o++) {
        field = __fields[o];
        T.get_T_fn(field.type)(this[field.name], field.name, null, str);
      }
      return this;
    };
    clazz.fromJSON = function(x) {
      var fields, v;
      T.simple_map(x, "input");
      fields = {};
      for (k in x) {
        v = x[k];
        field = __field_map[k];
        if (field != null) {
          type = field.type;
          if (type.fromJSON != null) {
            fields[k] = type.fromJSON(v);
          } else {
            fields[k] = v;
          }
        }
      }
      return new clazz(fields);
    };
    clazz.toString = function() {
      return "struct " + stname;
    };
    return clazz;
  };

  StructField = struct.define('StructField', [['name', T.string], ['type', T.defined], ['initFn', T.defined]]);

  struct.toJSO = function(x) {
    var e, k, out, v;
    if (typeof x !== 'object') {
      return x;
    }
    if (T.is_array(x)) {
      return (function() {
        var l, len1, results1;
        results1 = [];
        for (l = 0, len1 = x.length; l < len1; l++) {
          e = x[l];
          results1.push(struct.toJSO(e));
        }
        return results1;
      })();
    } else {
      out = {};
      for (k in x) {
        v = x[k];
        if (x.hasOwnProperty(k)) {
          out[k] = struct.toJSO(v);
        }
      }
      return out;
    }
  };

  struct.union_as_list = function(uname, variants_arg) {
    var __fields, __struct_fields, __tag, __tags, __variants_map, fn1, l, len1, msg, union, v;
    T.string(uname, "union name");
    T.array(variants_arg, "variants");
    union = function() {
      throw new Error("Use " + uname + ".from_array instead");
    };
    __variants_map = {};
    __tags = [];
    fn1 = function(__tag, __fields, __struct_fields) {
      var hacked_struct;
      hacked_struct = struct.define(uname + "." + __tag, __struct_fields);
      hacked_struct.prototype.tag = function() {
        return __tag;
      };
      hacked_struct.prototype.toString = function() {
        return uname + "." + __tag + "(" + (JSON.stringify(this)) + ")";
      };
      hacked_struct.prototype.toJSON = function() {
        var accu, field, len2, name, o, type;
        accu = [__tag];
        for (o = 0, len2 = __fields.length; o < len2; o++) {
          field = __fields[o];
          name = field[0];
          type = field[1];
          (T.get_T_fn(type))(this[name], name);
          accu.push(this[name]);
        }
        return accu;
      };
      hacked_struct.from_array = function(x) {
        var accu, field, i, len2, name, o, wanted;
        wanted = "initializer for " + uname;
        T.array(x, "initializer", wanted);
        T.check(x.length === __fields.length + 1, "does not have length " + (__fields.length + 1), x, "initializer", wanted);
        T.check(x[0] === __tag, "does not have tag " + __tag, x, "initializer", wanted);
        accu = {
          _tag: __tag
        };
        for (i = o = 0, len2 = __fields.length; o < len2; i = ++o) {
          field = __fields[i];
          name = field[0];
          accu[name] = x[i + 1];
        }
        return new hacked_struct(accu);
      };
      hacked_struct.fromJSON = function(x) {
        if (x.length > __fields.length + 1) {
          x = x.slice(0, __fields.length + 1);
        }
        return hacked_struct.from_array(x);
      };
      hacked_struct.coerce = function(x) {
        if (x instanceof hacked_struct) {
          hacked_struct.Type(x);
          return x;
        } else {
          return hacked_struct.from_array(x);
        }
      };
      __variants_map[__tag] = hacked_struct;
      return union[__tag] = hacked_struct;
    };
    for (l = 0, len1 = variants_arg.length; l < len1; l++) {
      v = variants_arg[l];
      T.array(v, "variant", "variant descriptor", variants_arg);
      T.check(v.length === 2, "does not have length 2", v, "variant descriptor", variants_arg);
      __tag = T.string(v[0], "tag", "tag", variants_arg);
      __fields = T.array(v[1], "fields", "variant descriptor", variants_arg);
      __struct_fields = __fields.slice(0);
      __struct_fields.unshift(['_tag', T.member([__tag])]);
      fn1(__tag, __fields, __struct_fields);
      __tags.push(__tag);
    }
    msg = "initializer for " + uname + " (variants " + (__tags.join(', ')) + ")";
    union.from_array = function(x) {
      var tag, wanted;
      wanted = "initializer for " + uname;
      T.array(x, "initializer", wanted);
      T.check(x.length >= 1, "lacks a tag", x, "initializer", wanted);
      tag = x[0];
      T.string(tag, "tag", wanted, x);
      (T.member(__tags))(tag);
      return __variants_map[tag].from_array(x);
    };
    union.fromJSON = function(x) {
      var tag, wanted;
      wanted = "initializer for " + uname;
      T.array(x, "initializer", wanted);
      T.check(x.length >= 1, "lacks a tag", x, "initializer", wanted);
      tag = x[0];
      T.string(tag, "tag", wanted, x);
      (T.member(__tags))(tag);
      return __variants_map[tag].fromJSON(x);
    };
    union.Type = function(x, what, wanted, top) {
      var tag;
      if (wanted == null) {
        wanted = uname + ".Type";
      }
      T.defined(x, what, wanted, top);
      T.defined(x.tag, "tag", wanted, top);
      tag = x.tag();
      T.string(tag, "tag", "initializer", x);
      (T.member(__tags))(tag);
      __variants_map[tag].Type(x, null, "object of type " + uname);
      return x;
    };
    union.coerce = function(x) {
      var s, t;
      for (t in __variants_map) {
        s = __variants_map[t];
        if (x instanceof s) {
          s.Type(x);
          return x;
        }
      }
      return union.from_array(x);
    };
    union.toString = function() {
      return "union " + uname;
    };
    return union;
  };

  impl.nonzero_int64_approximate_regex = new RegExp('^-?[1-9][0-9]{0,18}$');

  impl.int64_max_str = '9223372036854775807';

  impl.int64_min_str = '-9223372036854775808';

  impl.ACL_TID = ':acl';

  impl.ROLE_OWNER = 3000;

  impl.ROLE_EDITOR = 2000;

  impl.ROLE_VIEWER = 1000;

  impl.int64_string_less_than = function(x, y) {
    var x_magnitude_larger, x_neg, y_neg;
    if (x === y) {
      return false;
    }
    x_neg = (x.charAt(0)) === '0';
    y_neg = (y.charAt(0)) === '0';
    if (x_neg && !y_neg) {
      return true;
    }
    if (y_neg && !x_neg) {
      return false;
    }
    x_magnitude_larger = x.length === y.length ? x > y : x.length > y.length;
    if (x_neg && y_neg) {
      return x_magnitude_larger;
    }
    return !x_magnitude_larger;
  };

  impl.is_valid_int64_string = function(x) {
    if (!T.is_string(x)) {
      return false;
    }
    if (x === '0') {
      return true;
    }
    if (!impl.nonzero_int64_approximate_regex.test(x)) {
      return false;
    }
    if ((x.charAt(0)) === '-') {
      return (x.length < impl.int64_min_str.length) || (x <= impl.int64_min_str);
    } else {
      return (x.length < impl.int64_max_str.length) || (x <= impl.int64_max_str);
    }
  };

  impl.is_wrapped_atomic_field_value = function(x) {
    var keys, ref, ref1, y;
    if (!T.is_simple_map(x)) {
      return false;
    }
    keys = Object.keys(x);
    if (keys.length !== 1) {
      return false;
    }
    switch (keys[0]) {
      case 'B':
        return T.is_string(x.B);
      case 'N':
        return (ref = x.N) === 'nan' || ref === '+inf' || ref === '-inf';
      case 'I':
      case 'T':
        y = (ref1 = x.I) != null ? ref1 : x.T;
        return impl.is_valid_int64_string(y);
      default:
        return false;
    }
  };

  impl.is_atomic_field_value = function(x) {
    return (T.is_bool(x)) || (T.is_json_number(x)) || (T.is_string(x)) || (impl.is_wrapped_atomic_field_value(x));
  };

  impl.is_list_value = function(x) {
    var elt, l, len1;
    if (!T.is_array(x)) {
      return false;
    } else {
      for (l = 0, len1 = x.length; l < len1; l++) {
        elt = x[l];
        if (!impl.is_atomic_field_value(elt)) {
          return false;
        }
      }
      return true;
    }
  };

  impl.is_compound_field_value = function(x) {
    return (impl.is_atomic_field_value(x)) || (impl.is_list_value(x));
  };

  impl.atomic_field_value = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "atomic field value";
    }
    T.check(impl.is_atomic_field_value(x), "is not an atomic field value", x, what, wanted, top);
    return x;
  };

  impl.list_value = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "list value";
    }
    (T.arrayOf(impl.atomic_field_value))(x, what, wanted, top);
    return x;
  };

  impl.compound_field_value = function(x, what, wanted, top) {
    if (wanted == null) {
      wanted = "field value";
    }
    if (T.is_array(x)) {
      return impl.list_value(x, what, wanted, top);
    } else {
      return impl.atomic_field_value(x, what, wanted, top);
    }
  };

  impl.FieldOp = FieldOp = struct.union_as_list('FieldOp', [['P', [['value', impl.compound_field_value]]], ['D', []], ['LC', []], ['LP', [['at', T.uint], ['value', impl.atomic_field_value]]], ['LI', [['before', T.uint], ['value', impl.atomic_field_value]]], ['LD', [['at', T.uint]]], ['LM', [['from', T.uint], ['to', T.uint]]]]);

  impl.datadict = T.simple_typed_map('datadict', T.field_name, impl.compound_field_value);

  impl.update_datadict = T.simple_typed_map('update_datadict', T.field_name, FieldOp);

  impl.Change = Change = struct.union_as_list('Change', [['I', [['tid', T.tid], ['rowid', T.rowid], ['fields', impl.datadict]]], ['U', [['tid', T.tid], ['rowid', T.rowid], ['updates', impl.update_datadict]]], ['D', [['tid', T.tid], ['rowid', T.rowid]]]]);

  impl.Delta = Delta = struct.define('Delta', [['rev', T.uint], ['changes', T.arrayOf(Change)], ['nonce', T.string]]);

  ListDatastoresResponseItem = struct.define('ListDatastoresResponseItem', [
    ['dsid', T.string], ['handle', T.string], ['rev', T.uint], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ], [
      'info', T.nullable(impl.datadict), {
        init: null
      }
    ]
  ]);

  impl.ListDatastoresResponse = ListDatastoresResponse = struct.define('ListDatastoresResponse', [['token', T.string], ['datastores', T.arrayOf(ListDatastoresResponseItem)]]);

  GetSnapshotResponseRow = struct.define('GetSnapshotResponseRow', [['tid', T.string], ['rowid', T.string], ['data', impl.datadict]]);

  GetSnapshotResponse = struct.define('GetSnapshotResponse', [
    ['rev', T.uint], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ], ['rows', T.arrayOf(GetSnapshotResponseRow)]
  ]);

  CreateDatastoreResponse = struct.define('CreateDatastoreResponse', [
    ['handle', T.string], ['rev', T.uint], ['created', T.bool], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ]
  ]);

  GetDatastoreResponse = struct.define('GetDatastoreResponse', [
    [
      'handle', T.nullable(T.string), {
        init: null
      }
    ], [
      'rev', T.nullable(T.uint), {
        init: null
      }
    ], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ], [
      'notfound', T.nullable(T.string), {
        init: null
      }
    ]
  ]);

  DeleteDatastoreResponse = struct.define('DeleteDatastoresResponse', [['ok', T.string]]);

  PutDeltaResponse = struct.define('PutDeltaResponse', [
    [
      'rev', T.nullable(T.uint), {
        init: null
      }
    ], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ], [
      'conflict', T.nullable(T.string), {
        init: null
      }
    ], [
      'notfound', T.nullable(T.string), {
        init: null
      }
    ], [
      'access_denied', T.nullable(T.string), {
        init: null
      }
    ]
  ]);

  GetDeltasResponse = struct.define('GetDeltasResponse', [
    [
      'deltas', T.nullable(T.arrayOf(Delta)), {
        init: null
      }
    ], [
      'role', T.nullable(T.uint), {
        init: null
      }
    ], [
      'notfound', T.nullable(T.string), {
        init: null
      }
    ]
  ]);

  AwaitResponseDeltas = struct.define('AwaitResponseDeltas', [['deltas', T.simple_typed_map('deltas map', T.string, GetDeltasResponse)]]);

  impl.AwaitResponse = AwaitResponse = struct.define('AwaitResponse', [
    [
      'get_deltas', T.nullable(AwaitResponseDeltas), {
        init: null
      }
    ], [
      'list_datastores', T.nullable(ListDatastoresResponse), {
        init: null
      }
    ]
  ]);

  Backoff = (function() {
    function Backoff() {
      this.min_delay_millis = 500;
      this.max_delay_millis = 90000;
      this.base = 1.5;
      this._failures = 0;
      this.log = false;
    }

    Backoff.prototype.set_log = function(log) {
      this.log = log;
    };

    Backoff.prototype.set_max_delay_millis = function(max_delay_millis) {
      this.max_delay_millis = max_delay_millis;
    };

    Backoff.prototype.get_backoff_millis = function() {
      var delay_millis, target_delay_millis;
      this._failures += 1;
      target_delay_millis = Math.min(this.max_delay_millis, this.min_delay_millis * Math.pow(this.base, this._failures - 1));
      delay_millis = (.5 + Math.random()) * target_delay_millis;
      if (this.log) {
        console.log("get_backoff_millis: failures=" + this._failures + ", target_delay_millis=" + target_delay_millis + ", delay_millis=" + delay_millis);
      }
      return delay_millis;
    };

    Backoff.prototype.reset = function() {
      return this._failures = 0;
    };

    return Backoff;

  })();

  RetryWithBackoff = (function() {
    var COUNTER, DEFAULT_GIVEUP_AFTER_MS;

    DEFAULT_GIVEUP_AFTER_MS = 60 * 1000;

    COUNTER = 0;

    function RetryWithBackoff() {
      this.backoff = new Backoff;
    }

    RetryWithBackoff.prototype.run = function(to_run, options, cb) {
      var attempt, cancelled, do_retry, giveup_after_ms, giveup_threshold, ref, ref1;
      do_retry = (ref = options.do_retry) != null ? ref : (function() {
        return true;
      });
      giveup_after_ms = (ref1 = options.giveup_after_ms) != null ? ref1 : DEFAULT_GIVEUP_AFTER_MS;
      giveup_threshold = Date.now() + giveup_after_ms;
      cancelled = false;
      attempt = (function(_this) {
        return function() {
          if (cancelled) {
            return;
          }
          return to_run(function() {
            var err, more_args, to_wait;
            err = arguments[0], more_args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (cancelled) {
              return;
            }
            if (err && (do_retry(err))) {
              if (Date.now() > giveup_threshold) {
                console.error("Giving up due to error", err);
                return cb(err);
              }
              to_wait = _this.backoff.get_backoff_millis();
              console.warn("Retrying in " + to_wait + " ms due to error", err);
              return setTimeout(attempt, to_wait);
            } else {
              return cb.apply(null, [err].concat(slice.call(more_args)));
            }
          });
        };
      })(this);
      attempt();
      return (function() {
        return cancelled = true;
      });
    };

    return RetryWithBackoff;

  })();

  FlobClient = (function() {
    var OFFLINE_OP_MAX_RETRY_SECS, ONLINE_OP_MAX_RETRY_SECS;

    ONLINE_OP_MAX_RETRY_SECS = 10;

    OFFLINE_OP_MAX_RETRY_SECS = 60 * 60 * 24 * 7 * 4;

    function FlobClient(client1) {
      this.client = client1;
      this._retry = new RetryWithBackoff;
    }

    FlobClient.prototype._run_with_retries = function(give_up_after_seconds, cb, body) {
      var options;
      options = {
        giveup_after_ms: 1000 * give_up_after_seconds,
        do_retry: function(err) {
          var ref;
          return err.status === 0 || ((500 <= (ref = err.status) && ref < 600));
        }
      };
      return this._retry.run(body, options, cb);
    };

    FlobClient.prototype.delete_db = function(handle, cb) {
      return this._run_with_retries(ONLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._deleteDatastore(handle, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.list_dbs = function(cb) {
      return this._run_with_retries(OFFLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._listDatastores(function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.get_or_create_db = function(dsid, cb) {
      return this._run_with_retries(ONLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._getOrCreateDatastore(dsid, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.create_db = function(dsid, key, cb) {
      return this._run_with_retries(ONLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._createDatastore(dsid, key, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.get_db = function(dsid, cb) {
      return this._run_with_retries(ONLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._getDatastore(dsid, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.await = function(handle_version_map, db_list_token, cb) {
      var cancel_fn;
      cancel_fn = this._run_with_retries(OFFLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._datastoreAwait(handle_version_map, db_list_token, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
      return cancel_fn;
    };

    FlobClient.prototype.put_delta = function(handle, flob_delta, cb) {
      return this._run_with_retries(OFFLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._putDelta(handle, flob_delta, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    FlobClient.prototype.get_snapshot = function(handle, cb) {
      return this._run_with_retries(ONLINE_OP_MAX_RETRY_SECS, cb, (function(_this) {
        return function(cb) {
          return _this.client._getSnapshot(handle, function(err, resp) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, resp);
          });
        };
      })(this));
    };

    return FlobClient;

  })();

  LocalDelta = (function() {
    var _make_inverse;

    _make_inverse = function(change, undo_extra) {
      var arr, data, k, tag, v;
      tag = null;
      data = null;
      switch (change.tag()) {
        case 'I':
          tag = 'D';
          break;
        case 'U':
          tag = 'U';
          data = {};
          for (k in undo_extra) {
            v = undo_extra[k];
            if (v == null) {
              data[k] = ['D'];
            } else {
              data[k] = ['P', v];
            }
          }
          break;
        case 'D':
          tag = 'I';
          data = impl.clone(undo_extra);
          break;
        default:
          throw new Error("Unknown change tag: " + (change.tag()));
      }
      arr = [tag, change.tid, change.rowid];
      if (data != null) {
        arr.push(data);
      }
      return Change.from_array(arr);
    };

    function LocalDelta(new_changes, new_undo_extras) {
      var i, l, ref;
      T.assert(new_changes.length === new_undo_extras.length, function() {
        return new_changes.length + " changes, " + new_undo_extras.length + " undo_extras";
      });
      this.changes = [];
      this.undo_extras = [];
      this._last_simple_mtime_update = null;
      for (i = l = 0, ref = new_changes.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        this.add_change(new_changes[i], new_undo_extras[i]);
      }
    }

    LocalDelta._is_simple_mtime_update = function(change) {
      var field_op, keys;
      switch (change.tag()) {
        case 'I':
        case 'D':
          return false;
        case 'U':
          if (!((change.tid === ':info') && (change.rowid === 'info'))) {
            return false;
          }
          keys = Object.keys(change.updates);
          if (keys.length !== 1) {
            return false;
          }
          if (keys[0] !== 'mtime') {
            return false;
          }
          field_op = change.updates['mtime'];
          switch (field_op.tag()) {
            case 'P':
              return true;
            case 'D':
            case 'LC':
            case 'LP':
            case 'LI':
            case 'LD':
            case 'LM':
              return false;
            default:
              throw new Error("Unknown field op: " + (field_op.tag()));
          }
          break;
        default:
          throw new Error("Unknown change tag: " + (change.tag()));
      }
    };

    LocalDelta._affects_mtime = function(change) {
      if (!((change.tid === ':info') && (change.rowid === 'info'))) {
        return false;
      }
      switch (change.tag()) {
        case 'I':
        case 'D':
          return true;
        case 'U':
          if ('mtime' in change.updates) {
            return true;
          } else {
            return false;
          }
          break;
        default:
          throw new Error("Unknown change tag: " + (change.tag()));
      }
    };

    LocalDelta.prototype.add_change = function(change, undo_extra) {
      this.changes.push(change);
      this.undo_extras.push(undo_extra);
      if (LocalDelta._affects_mtime(change)) {
        if (LocalDelta._is_simple_mtime_update(change)) {
          if (this._last_simple_mtime_update != null) {
            this.changes.splice(this._last_simple_mtime_update, 1);
            this.undo_extras.splice(this._last_simple_mtime_update, 1);
          }
          this._last_simple_mtime_update = this.changes.length - 1;
        } else {
          this._last_simple_mtime_update = null;
        }
      }
      return void 0;
    };

    LocalDelta.prototype.inverse_changes = function() {
      var change, idx, l, len1, ref, ret;
      ret = [];
      ref = this.changes;
      for (idx = l = 0, len1 = ref.length; l < len1; idx = ++l) {
        change = ref[idx];
        ret.push(_make_inverse(change, this.undo_extras[idx]));
      }
      ret.reverse();
      return ret;
    };

    return LocalDelta;

  })();

  impl.LocalDelta = LocalDelta;

  NONCE_LENGTH = 10;

  NONCE_VALUE_SIZE = NONCE_LENGTH;

  impl.make_nonce = function() {
    return impl.randomWeb64String(NONCE_LENGTH);
  };

  impl.value_size = function(x) {
    var l, len1, size, y;
    if (T.is_string(x)) {
      return Dropbox.Util.countUtf8Bytes(x);
    } else if (T.is_bool(x)) {
      return 0;
    } else if (T.is_number(x)) {
      return 0;
    } else if (T.is_array(x)) {
      size = Dropbox.Datastore.List.BASE_ITEM_SIZE * x.length;
      for (l = 0, len1 = x.length; l < len1; l++) {
        y = x[l];
        size += impl.value_size(y);
      }
      return size;
    } else {
      if (typeof x !== 'object') {
        throw new Error("Unexpected value: " + x);
      }
      if (x.I != null) {
        return 0;
      } else if (x.N != null) {
        return 0;
      } else if (x.B != null) {
        return Math.ceil(x.B.length * 3 / 4);
      } else if (x.T != null) {
        return 0;
      } else {
        throw new Error("Unexpected object: " + (JSON.stringify(x)));
      }
    }
  };

  impl.size_difference_for_field_op = function(record, field_name, field_op) {
    var current_value, new_value, ref, ref1;
    current_value = record.get(field_name);
    switch (field_op.tag()) {
      case 'P':
        new_value = field_op.value;
        if (current_value == null) {
          return Dropbox.Datastore.Record.BASE_FIELD_SIZE + impl.value_size(new_value);
        } else {
          return (impl.value_size(new_value)) - (impl.value_size(current_value));
        }
        break;
      case 'D':
        if (current_value != null) {
          return -(Dropbox.Datastore.Record.BASE_FIELD_SIZE + impl.value_size(current_value));
        } else {
          return 0;
        }
        break;
      case 'LC':
        assert(current_value == null, "can't create list for field that already exists");
        return Dropbox.Datastore.Record.BASE_FIELD_SIZE;
      case 'LP':
        assert(T.is_array(current_value), "LP on non-list");
        assert((0 <= (ref = field_op.at) && ref < current_value.length), "bad index for LP");
        return (impl.value_size(field_op.value)) - (impl.value_size(current_value[field_op.at]));
      case 'LI':
        return (current_value != null ? 0 : Dropbox.Datastore.Record.BASE_FIELD_SIZE) + Dropbox.Datastore.List.BASE_ITEM_SIZE + impl.value_size(field_op.value);
      case 'LD':
        assert(T.is_array(current_value), "LD on non-list");
        assert((0 <= (ref1 = field_op.at) && ref1 < current_value.length), "bad index for LD");
        return -(Dropbox.Datastore.List.BASE_ITEM_SIZE + impl.value_size(current_value[field_op.at]));
      case 'LM':
        return 0;
      default:
        throw new Error("unexpected field op type " + (field_op.tag()));
    }
  };

  impl.size_difference_for_change = function(datastore, change) {
    var field_name, field_op, record, size, size_difference, total, value;
    size_difference = (function() {
      var ref, ref1;
      switch (change.tag()) {
        case 'I':
          size = Dropbox.Datastore.Record.BASE_RECORD_SIZE;
          ref = change.fields;
          for (field_name in ref) {
            value = ref[field_name];
            size += Dropbox.Datastore.Record.BASE_FIELD_SIZE + impl.value_size(value);
          }
          return size;
        case 'U':
          record = datastore.get_record(change.tid, change.rowid);
          T.assert(record != null, function() {
            return "record not found: " + (JSON.stringify(change));
          });
          total = 0;
          ref1 = change.updates;
          for (field_name in ref1) {
            field_op = ref1[field_name];
            total += impl.size_difference_for_field_op(record, field_name, field_op);
          }
          return total;
        case 'D':
          return -(datastore.get_record(change.tid, change.rowid))._size;
        default:
          throw new Error("unrecognized tag " + (change.tag()));
      }
    })();
    return size_difference;
  };

  RecordModel = (function() {
    function RecordModel(_tid, _rid, fields) {
      var field_name, value;
      this._tid = _tid;
      this._rid = _rid;
      if (fields == null) {
        fields = {};
      }
      this._fields = {};
      this._size = Dropbox.Datastore.Record.BASE_RECORD_SIZE;
      for (field_name in fields) {
        value = fields[field_name];
        this._fields[field_name] = impl.clone(value);
        this._size += Dropbox.Datastore.Record.BASE_FIELD_SIZE + impl.value_size(value);
      }
      void 0;
    }

    RecordModel.prototype.get = function(field_name) {
      return this._fields[field_name];
    };

    RecordModel.prototype.get_all = function() {
      return this._fields;
    };

    RecordModel.prototype.put = function(field_name, value) {
      if (value != null) {
        this._fields[field_name] = impl.clone(value);
      } else {
        delete this._fields[field_name];
      }
      return void 0;
    };

    RecordModel.prototype.apply_field_op = function(field_name, field_op) {
      var field, ref, ref1, ref2, ref3, ref4, val;
      field = this._fields[field_name];
      switch (field_op.tag()) {
        case 'P':
          this._fields[field_name] = impl.clone(field_op.value);
          break;
        case 'D':
          delete this._fields[field_name];
          break;
        case 'LC':
          assert(field == null, "can't create list for field that already exists");
          this._fields[field_name] = [];
          break;
        case 'LP':
          assert(T.is_array(field), "LP on non-list");
          assert((0 <= (ref = field_op.at) && ref < field.length), "bad index for LP");
          field[field_op.at] = impl.clone(field_op.value);
          break;
        case 'LI':
          if (field != null) {
            assert(T.is_array(field), "LI on non-list");
            assert((0 <= (ref1 = field_op.before) && ref1 <= field.length), "bad index for LI");
            field.splice(field_op.before, 0, impl.clone(field_op.value));
          } else {
            assert(field_op.before === 0, "bad index for LI on nonexistent field");
            this._fields[field_name] = [impl.clone(field_op.value)];
          }
          break;
        case 'LD':
          assert(T.is_array(field), "LD on non-list");
          assert((0 <= (ref2 = field_op.at) && ref2 < field.length), "bad index for LD");
          field.splice(field_op.at, 1);
          break;
        case 'LM':
          assert(T.is_array(field), "LM on non-list");
          assert((0 <= (ref3 = field_op.from) && ref3 < field.length), "bad from index for LM");
          assert((0 <= (ref4 = field_op.to) && ref4 < field.length), "bad to index for LM");
          val = field[field_op.from];
          field.splice(field_op.from, 1);
          field.splice(field_op.to, 0, val);
          break;
        default:
          throw new Error("unexpected field op type " + (field_op.tag()));
      }
      return void 0;
    };

    RecordModel.prototype.size = function() {
      return this._size;
    };

    return RecordModel;

  })();

  TableModel = (function() {
    function TableModel() {
      this._records = {};
      void 0;
    }

    TableModel.prototype.get = function(rid) {
      return this._records[rid];
    };

    TableModel.prototype.put = function(rid, record) {
      if (record != null) {
        this._records[rid] = record;
      } else {
        delete this._records[rid];
      }
      return void 0;
    };

    TableModel.prototype.has = function(rid) {
      return this._records[rid] != null;
    };

    TableModel.prototype.is_empty = function() {
      var x;
      for (x in this._records) {
        return false;
      }
      return true;
    };

    TableModel.prototype.list_record_ids = function() {
      var results1, rid;
      results1 = [];
      for (rid in this._records) {
        results1.push(rid);
      }
      return results1;
    };

    return TableModel;

  })();

  DatastoreModel = (function() {
    DatastoreModel.from_get_snapshot_resp = function(resp) {
      var l, len1, name1, out, ref, row;
      out = {};
      ref = resp.rows;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        row = ref[l];
        out[name1 = row.tid] || (out[name1] = {});
        out[row.tid][row.rowid] = row.data;
      }
      return new DatastoreModel(false, out);
    };

    function DatastoreModel(enforce_limit_during_construction, data) {
      var fields, record, records, rid, table, tid;
      this._tables = {};
      this._record_count = 0;
      this._size = Dropbox.Datastore.BASE_DATASTORE_SIZE;
      for (tid in data) {
        records = data[tid];
        table = this._get_table(tid);
        for (rid in records) {
          fields = records[rid];
          record = new RecordModel(tid, rid, fields);
          this._check_record_size(enforce_limit_during_construction, tid, rid, record._size);
          table.put(rid, record);
          this._record_count += 1;
          this._size += record._size;
        }
      }
      this._check_datastore_size(enforce_limit_during_construction, this._size);
      this._changedInfoFields = {};
      void 0;
    }

    DatastoreModel.prototype._size_limit_exceeded = function(enforce_limit, msg) {
      var err;
      if (enforce_limit) {
        err = new Error(msg);
        err.code = 'SIZE_LIMIT_EXCEEDED';
        throw err;
      } else {
        console.warn(msg);
        return void 0;
      }
    };

    DatastoreModel.prototype._check_record_size = function(enforce_limit, tid, rid, size) {
      if (size > Dropbox.Datastore.Record.RECORD_SIZE_LIMIT) {
        this._size_limit_exceeded(enforce_limit, "Record (" + tid + ", " + rid + ") too large: " + size + " bytes");
      }
      return void 0;
    };

    DatastoreModel.prototype._check_datastore_size = function(enforce_limit, size) {
      if (size > Dropbox.Datastore.DATASTORE_SIZE_LIMIT) {
        this._size_limit_exceeded(enforce_limit, "Datastore too large: " + size + " bytes");
      }
      return void 0;
    };

    DatastoreModel.prototype._TEST_calculate_size_from_scratch = function() {
      var fname, l, len1, record, ref, ref1, ref2, rid, size, table, tid, value;
      size = 0;
      ref = this._tables;
      for (tid in ref) {
        table = ref[tid];
        ref1 = table.list_record_ids();
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          rid = ref1[l];
          record = table.get(rid);
          size += Dropbox.Datastore.Record.BASE_RECORD_SIZE;
          ref2 = record.get_all();
          for (fname in ref2) {
            value = ref2[fname];
            size += Dropbox.Datastore.Record.BASE_FIELD_SIZE + impl.value_size(value);
          }
        }
      }
      return size;
    };

    DatastoreModel.prototype.raw_data = function() {
      var l, len1, out, ref, ref1, rid, table, tid;
      out = {};
      ref = this._tables;
      for (tid in ref) {
        table = ref[tid];
        out[tid] = {};
        ref1 = table.list_record_ids();
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          rid = ref1[l];
          out[tid][rid] = impl.clone((table.get(rid)).get_all());
        }
      }
      return out;
    };

    DatastoreModel.prototype.get_record = function(tid, rid) {
      var ref;
      return (ref = this._tables[tid]) != null ? ref.get(rid) : void 0;
    };

    DatastoreModel.prototype.clearInfoFields = function() {
      return this._changedInfoFields = {};
    };

    DatastoreModel.prototype.updateInfoFieldsFromChange = function(change) {
      var field_name, infoRecord, insert, ref, ref1, results1, results2, results3, update;
      T.assert(change.tid === ':info', function() {
        return "updateInfoField: table must be :info, got " + change.tid;
      });
      T.assert(change.rowid === 'info', function() {
        return "updateInfoField: row must be info, got " + change.rowid;
      });
      switch (change.tag()) {
        case 'I':
          ref = change.fields;
          results1 = [];
          for (field_name in ref) {
            insert = ref[field_name];
            results1.push(this._changedInfoFields[field_name] = true);
          }
          return results1;
          break;
        case 'U':
          ref1 = change.updates;
          results2 = [];
          for (field_name in ref1) {
            update = ref1[field_name];
            results2.push(this._changedInfoFields[field_name] = true);
          }
          return results2;
          break;
        case 'D':
          infoRecord = this.get_record(':info', 'info');
          if (infoRecord != null) {
            results3 = [];
            for (field_name in infoRecord.get_all()) {
              results3.push(this._changedInfoFields[field_name] = true);
            }
            return results3;
          }
          break;
        default:
          throw new Error("Unknown change tag: " + (change.tag()));
      }
    };

    DatastoreModel.prototype.updateDatastoreInfo = function(info) {
      var local_fields, name;
      info = impl.clone(info || {});
      local_fields = (this.query(':info', 'info')) || {};
      for (name in this._changedInfoFields) {
        if (name in local_fields) {
          info[name] = local_fields[name];
        } else {
          delete info[name];
        }
      }
      return info;
    };

    DatastoreModel.prototype.getLocalInfoData = function() {
      return impl.clone((this.query(':info', 'info')) || {});
    };

    DatastoreModel.prototype.apply_change = function(enforce_limit, change) {
      var amount, record, undo_extra;
      amount = impl.size_difference_for_change(this, change);
      if (amount >= 0) {
        this._check_datastore_size(enforce_limit, this._size + amount);
      }
      if (change.tid === ':info' && change.rowid === 'info') {
        this.updateInfoFieldsFromChange(change);
      }
      switch (change.tag()) {
        case 'I':
          this._check_record_size(enforce_limit, change.tid, change.rowid, amount);
          this._record_count += 1;
          undo_extra = this._apply_insert(change);
          break;
        case 'U':
          record = this.get_record(change.tid, change.rowid);
          T.assert(record != null, function() {
            return "apply_change: record does not exist: " + (JSON.stringify(change));
          });
          if (amount >= 0) {
            this._check_record_size(enforce_limit, change.tid, change.rowid, record._size + amount);
          }
          undo_extra = this._apply_update(record, change);
          record._size += amount;
          break;
        case 'D':
          this._record_count -= 1;
          undo_extra = this._apply_delete(change);
          break;
        default:
          throw new Error("unrecognized tag " + (change.tag()));
      }
      this._size += amount;
      return undo_extra;
    };

    DatastoreModel.prototype._get_table = function(tid) {
      if (this._tables[tid] == null) {
        this._tables[tid] = new TableModel;
      }
      return this._tables[tid];
    };

    DatastoreModel.prototype._apply_insert = function(change) {
      var record, table;
      table = this._get_table(change.tid);
      T.assert(!table.has(change.rowid), function() {
        return "_apply_insert: record already exists: " + (JSON.stringify(change));
      });
      record = new RecordModel(change.tid, change.rowid, change.fields);
      table.put(change.rowid, record);
      return null;
    };

    DatastoreModel.prototype._apply_update = function(record, change) {
      var err, field_name, field_op, old_data, old_value, ref, ref1;
      old_data = {};
      try {
        ref = change.updates;
        for (field_name in ref) {
          field_op = ref[field_name];
          old_value = impl.clone((ref1 = record.get(field_name)) != null ? ref1 : null);
          record.apply_field_op(field_name, field_op);
          old_data[field_name] = old_value;
        }
      } catch (_error) {
        err = _error;
        for (field_name in old_data) {
          old_value = old_data[field_name];
          record.put(false, field_name, old_value);
        }
        throw err;
      }
      return old_data;
    };

    DatastoreModel.prototype._apply_delete = function(change) {
      var old_data, record, table;
      table = this._get_table(change.tid);
      T.assert(table.has(change.rowid), function() {
        return "_apply_delete: record does not exist: " + (JSON.stringify(change));
      });
      record = table.get(change.rowid);
      old_data = impl.clone(record.get_all());
      table.put(change.rowid, null);
      if (table.is_empty()) {
        delete this._tables[change.tid];
      }
      return old_data;
    };

    DatastoreModel.prototype.query = function(tid, rid) {
      var record, table;
      table = this._tables[tid];
      if (table == null) {
        return null;
      }
      record = table.get(rid);
      if (record == null) {
        return null;
      }
      return impl.clone(record.get_all());
    };

    DatastoreModel.prototype.list_tables = function() {
      var ret, tid;
      ret = (function() {
        var results1;
        results1 = [];
        for (tid in this._tables) {
          results1.push(tid);
        }
        return results1;
      }).call(this);
      ret.sort();
      return ret;
    };

    DatastoreModel.prototype.list_rows_for_table = function(tid) {
      var ret, table;
      table = this._tables[tid];
      if (table == null) {
        return [];
      }
      ret = table.list_record_ids();
      ret.sort();
      return ret;
    };

    DatastoreModel.prototype.record_count = function() {
      return this._record_count;
    };

    DatastoreModel.prototype.size = function() {
      return this._size;
    };

    return DatastoreModel;

  })();

  ManagedDatastore = (function() {
    ManagedDatastore.fresh_managed_datastore = function(dbid, handle, role, datastore_model, rev, resolver, flob_client, dslist_listener) {
      var sync_state;
      sync_state = new SyncState(rev);
      return new ManagedDatastore(dbid, handle, role, datastore_model, resolver, sync_state, flob_client, dslist_listener);
    };

    function ManagedDatastore(dbid1, handle1, role1, datastore_model1, resolver1, sync_state1, flob_client1, _dslist_listener) {
      this.dbid = dbid1;
      this.handle = handle1;
      this.role = role1;
      this.datastore_model = datastore_model1;
      this.resolver = resolver1;
      this.sync_state = sync_state1;
      this.flob_client = flob_client1;
      this._dslist_listener = _dslist_listener;
      this.syncStateChanged = new Dropbox.Util.EventSource;
      this._deleted = false;
      this._open = true;
      this._put_delta_queue = new SyncQueue;
      this._update_mtime_on_change = true;
    }

    ManagedDatastore.prototype.get_dsid = function() {
      return this.dbid;
    };

    ManagedDatastore.prototype.get_handle = function() {
      return this.handle;
    };

    ManagedDatastore.prototype.get_effective_role = function() {
      return this.role;
    };

    ManagedDatastore.prototype.is_deleted = function() {
      return this._deleted;
    };

    ManagedDatastore.prototype.mark_deleted = function() {
      return this._deleted = true;
    };

    ManagedDatastore.prototype.open = function() {
      if (this._open) {
        throw new Error("Attempt to open datastore multiple times");
      }
      return this._open = true;
    };

    ManagedDatastore.prototype.close = function() {
      if (!this._open) {
        throw new Error("Attempt to close datastore multiple times");
      }
      return this._open = false;
    };

    ManagedDatastore.prototype.is_closed = function() {
      return !this._open;
    };

    ManagedDatastore.prototype._updateInfoFieldsAfterSync = function() {
      var change, delta, l, len1, ref, results1;
      this.datastore_model.clearInfoFields();
      ref = this.sync_state.unsynced_deltas;
      results1 = [];
      for (l = 0, len1 = ref.length; l < len1; l++) {
        delta = ref[l];
        results1.push((function() {
          var len2, o, ref1, results2;
          ref1 = delta.changes;
          results2 = [];
          for (o = 0, len2 = ref1.length; o < len2; o++) {
            change = ref1[o];
            if (change.tid === ':info' && change.rowid === 'info') {
              results2.push(this.datastore_model.updateInfoFieldsFromChange(change));
            } else {
              results2.push(void 0);
            }
          }
          return results2;
        }).call(this));
      }
      return results1;
    };

    ManagedDatastore.prototype._should_notify_dslist_listener_for = function(change) {
      var has_fields_other_than_mtime, record;
      has_fields_other_than_mtime = function(fields_or_updates) {
        var name;
        for (name in fields_or_updates) {
          if (name !== 'mtime') {
            return true;
          }
        }
        return false;
      };
      if (!(change.tid === ':info' && change.rowid === 'info')) {
        return false;
      }
      switch (change.tag()) {
        case 'D':
          record = this.datastore_model.get_record(change.tid, change.rowid);
          if (record == null) {
            throw new Error("Record not found: " + change.tid + " " + change.rowid);
          }
          return has_fields_other_than_mtime(record.get_all());
        case 'U':
          return has_fields_other_than_mtime(change.updates);
        case 'I':
          return has_fields_other_than_mtime(change.fields);
        default:
          throw new Error("unknown change tag: " + (change.tag()));
      }
    };

    ManagedDatastore.prototype._rollback_unsynced_deltas = function(compute_affected_records) {
      var affected_records, c, change, changes, delta, l, len1, len2, len3, o, p, reversed_deltas;
      affected_records = {};
      reversed_deltas = this.sync_state.unsynced_deltas.slice().reverse();
      for (l = 0, len1 = reversed_deltas.length; l < len1; l++) {
        delta = reversed_deltas[l];
        changes = delta.inverse_changes();
        for (o = 0, len2 = changes.length; o < len2; o++) {
          change = changes[o];
          this.datastore_model.apply_change(false, change);
        }
        if (compute_affected_records) {
          for (p = 0, len3 = changes.length; p < len3; p++) {
            c = changes[p];
            if (!(c.tid in affected_records)) {
              affected_records[c.tid] = {};
            }
            affected_records[c.tid][c.rowid] = true;
          }
        }
      }
      return affected_records;
    };

    ManagedDatastore.prototype._do_sync = function() {
      var affected_records, change, delta, l, len1, len2, len3, len4, new_local_deltas, o, p, q, ref, ref1, res_info, server_deltas, should_notify_dslist, undo_extra;
      server_deltas = this.sync_state.get_server_deltas();
      if (server_deltas.length === 0) {
        return {};
      }
      res_info = this.resolver.resolve(this.sync_state.unsynced_deltas, server_deltas);
      new_local_deltas = res_info.rebased_deltas;
      affected_records = res_info.affected_records;
      should_notify_dslist = false;
      this._rollback_unsynced_deltas(false);
      for (l = 0, len1 = server_deltas.length; l < len1; l++) {
        delta = server_deltas[l];
        ref = delta.changes;
        for (o = 0, len2 = ref.length; o < len2; o++) {
          change = ref[o];
          should_notify_dslist |= this._should_notify_dslist_listener_for(change);
          this.datastore_model.apply_change(false, change);
        }
      }
      for (p = 0, len3 = new_local_deltas.length; p < len3; p++) {
        delta = new_local_deltas[p];
        delta.undo_extras = [];
        ref1 = delta.changes;
        for (q = 0, len4 = ref1.length; q < len4; q++) {
          change = ref1[q];
          should_notify_dslist |= this._should_notify_dslist_listener_for(change);
          undo_extra = this.datastore_model.apply_change(false, change);
          delta.undo_extras.push(undo_extra);
        }
      }
      this.sync_state.update_unsynced_deltas(new_local_deltas);
      if (should_notify_dslist) {
        this._dslist_listener();
      }
      return affected_records;
    };

    ManagedDatastore.prototype._do_put_delta = function() {
      var delta;
      if (this.sync_state.delta_pending()) {
        return;
      }
      delta = this.sync_state.get_delta_to_put();
      if (delta == null) {
        return;
      }
      return this._put_delta_queue.request((function(_this) {
        return function() {
          return _this.flob_client.put_delta(_this.handle, delta, function(err, resp) {
            if (err == null) {
              if (resp.rev != null) {
                _this.sync_state.put_succeeded(delta);
                _this.syncStateChanged.dispatch(null);
              }
              if (resp.access_denied != null) {
                console.log("Write access denied, reverting pending changes. Reason:", resp.access_denied);
                _this._affected_records_from_access_denied = _this._rollback_unsynced_deltas(true);
                _this.sync_state.clear_unsynced_deltas();
                _this.role = impl.ROLE_VIEWER;
                _this.syncStateChanged.dispatch(null);
              }
            }
            return _this._put_delta_queue.finish();
          });
        };
      })(this));
    };

    ManagedDatastore.prototype._apply_and_queue_local_change = function(enforce_limit, change) {
      var should_notify_dslist, undo_extra;
      should_notify_dslist = this._should_notify_dslist_listener_for(change);
      undo_extra = this.datastore_model.apply_change(enforce_limit, change);
      this.sync_state.add_unsynced_change(change, undo_extra);
      if (should_notify_dslist) {
        this._dslist_listener();
      }
      return void 0;
    };

    ManagedDatastore.prototype._clock = function() {
      return new Date();
    };

    ManagedDatastore.prototype._update_mtime = function() {
      var mtime_change;
      if (!this._update_mtime_on_change) {
        return null;
      }
      mtime_change = (this.datastore_model.query(':info', 'info')) != null ? Change.from_array([
        'U', ':info', 'info', {
          mtime: ['P', impl.toDsValue(this._clock())]
        }
      ]) : Change.from_array([
        'I', ':info', 'info', {
          mtime: impl.toDsValue(this._clock())
        }
      ]);
      return this._apply_and_queue_local_change(false, mtime_change);
    };

    ManagedDatastore.prototype.perform_local_change = function(change) {
      this._apply_and_queue_local_change(true, change);
      this._update_mtime();
      return this.syncStateChanged.dispatch(null);
    };

    ManagedDatastore.prototype.sync = function() {
      var affected_records;
      affected_records = this._affected_records_from_access_denied;
      if (affected_records != null) {
        delete this._affected_records_from_access_denied;
        return affected_records;
      }
      if (this.has_unfinalized_changes()) {
        this.sync_state.finalize();
      }
      affected_records = this._do_sync();
      this._do_put_delta();
      this._updateInfoFieldsAfterSync();
      return affected_records;
    };

    ManagedDatastore.prototype.get_outgoing_delta_count = function() {
      return this.sync_state.unsynced_deltas.length;
    };

    ManagedDatastore.prototype.get_incoming_delta_count = function() {
      return this.sync_state.get_server_deltas().length;
    };

    ManagedDatastore.prototype.has_unfinalized_changes = function() {
      return this.sync_state.has_unfinalized_changes();
    };

    ManagedDatastore.prototype.receive_server_delta = function(delta) {
      this.sync_state.receive_server_delta(delta);
      this.syncStateChanged.dispatch(null);
      return void 0;
    };

    ManagedDatastore.prototype.query = function(tid, rid) {
      return this.datastore_model.query(tid, rid);
    };

    ManagedDatastore.prototype.list_tables = function() {
      var tid;
      return (function() {
        var l, len1, ref, results1;
        ref = this.datastore_model.list_tables();
        results1 = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          tid = ref[l];
          if (tid !== ':info' && tid !== impl.ACL_TID) {
            results1.push(tid);
          }
        }
        return results1;
      }).call(this);
    };

    ManagedDatastore.prototype.list_rows_for_table = function(tid) {
      return this.datastore_model.list_rows_for_table(tid);
    };

    ManagedDatastore.prototype.get_record_count = function() {
      return this.datastore_model.record_count();
    };

    ManagedDatastore.prototype.get_record_size = function(tid, rid) {
      return this.datastore_model.get_record(tid, rid).size();
    };

    ManagedDatastore.prototype.get_size = function() {
      return this.datastore_model.size();
    };

    return ManagedDatastore;

  })();

  SyncState = (function() {
    function SyncState(_server_rev) {
      this._server_rev = _server_rev;
      T.uint(this._server_rev, "_server_rev");
      this._pending_delta = null;
      this._server_deltas = [];
      this.unsynced_deltas = [];
      this._last_unsynced_delta_unfinalized = false;
    }

    SyncState.prototype.get_server_rev = function() {
      return this._server_rev;
    };

    SyncState.prototype.is_current = function() {
      return this.unsynced_deltas.length === 0 && this._server_deltas.length === 0;
    };

    SyncState.prototype.get_server_deltas = function() {
      return this._server_deltas;
    };

    SyncState.prototype.add_unsynced_change = function(change, undo_extra) {
      var len;
      len = this.unsynced_deltas.length;
      if (this._last_unsynced_delta_unfinalized) {
        this.unsynced_deltas[len - 1].add_change(change, undo_extra);
      } else {
        this.unsynced_deltas.push(new LocalDelta([change], [undo_extra]));
        this._last_unsynced_delta_unfinalized = true;
      }
      return void 0;
    };

    SyncState.prototype._compact_deltas = function() {
      var c, changes, delta, l, len, len1, len2, len3, o, p, ref, ref1, ref2, u, undo_extras, unfinalized_delta;
      assert(this._pending_delta == null, "delta pending");
      len = this.unsynced_deltas.length;
      if (len <= 1) {
        return;
      }
      unfinalized_delta = this._last_unsynced_delta_unfinalized ? this.unsynced_deltas.pop() : null;
      changes = [];
      undo_extras = [];
      ref = this.unsynced_deltas;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        delta = ref[l];
        ref1 = delta.changes;
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          c = ref1[o];
          changes.push(c);
        }
        ref2 = delta.undo_extras;
        for (p = 0, len3 = ref2.length; p < len3; p++) {
          u = ref2[p];
          undo_extras.push(u);
        }
      }
      this.unsynced_deltas = [new LocalDelta(changes, undo_extras)];
      if (unfinalized_delta != null) {
        this.unsynced_deltas.push(unfinalized_delta);
      }
      return void 0;
    };

    SyncState.prototype.get_delta_to_put = function() {
      var len, next_delta;
      assert(this._pending_delta == null, "delta pending");
      len = this.unsynced_deltas.length;
      if (len === 0 || (len === 1 && this._last_unsynced_delta_unfinalized)) {
        return null;
      }
      this._compact_deltas();
      if (this._last_unsynced_delta_unfinalized) {
        assert(this.unsynced_deltas.length > 1, "the only delta is unfinalized");
      }
      next_delta = this.unsynced_deltas[0];
      this._pending_delta = new Delta({
        changes: next_delta.changes.slice(),
        nonce: impl.make_nonce(),
        rev: this._server_rev
      });
      return this._pending_delta;
    };

    SyncState.prototype.delta_pending = function() {
      return this._pending_delta != null;
    };

    SyncState.prototype.has_unfinalized_changes = function() {
      return this._last_unsynced_delta_unfinalized;
    };

    SyncState.prototype.finalize = function() {
      this._last_unsynced_delta_unfinalized = false;
      return void 0;
    };

    SyncState.prototype.update_unsynced_deltas = function(new_deltas) {
      this.unsynced_deltas = new_deltas;
      this._server_rev += this._server_deltas.length;
      return this._server_deltas = [];
    };

    SyncState.prototype._is_our_pending = function(server_delta) {
      return (this._pending_delta != null) && this._pending_delta.nonce === server_delta.nonce;
    };

    SyncState.prototype._ack = function(server_delta) {
      assert(this._is_our_pending(server_delta), "not ours");
      assert(this._server_deltas.length === 0, "server deltas exist");
      this._pending_delta = null;
      this.unsynced_deltas.shift();
      return this._server_rev++;
    };

    SyncState.prototype.put_succeeded = function(delta) {
      if (this._is_our_pending(delta)) {
        return this._ack(delta);
      }
    };

    SyncState.prototype.clear_unsynced_deltas = function() {
      this._pending_delta = null;
      this.unsynced_deltas = [];
      return this._last_unsynced_delta_unfinalized = false;
    };

    SyncState.prototype.receive_server_delta = function(delta) {
      var expected_rev, len;
      len = this._server_deltas.length;
      expected_rev = len > 0 ? this._server_deltas[len - 1].rev + 1 : this._server_rev;
      assert(delta.rev <= expected_rev, "was expecting rev " + expected_rev + ", but got " + delta.rev + " instead!");
      if (delta.rev < expected_rev) {
        return;
      }
      if (this._is_our_pending(delta)) {
        this._ack(delta);
      } else {
        this._server_deltas.push(delta);
        this._pending_delta = null;
      }
      return void 0;
    };

    return SyncState;

  })();

  impl.DatastoreModel = DatastoreModel;

  PendingPoll = (function() {
    function PendingPoll(update_manager) {
      this.update_manager = update_manager;
      this.cancelled = false;
      this.cancel_fn = null;
    }

    PendingPoll.prototype.cancel = function() {
      if (this.cancel_fn != null) {
        this.cancel_fn();
      }
      return this.cancelled = true;
    };

    PendingPoll.prototype.poll = function() {
      var do_one_poll;
      do_one_poll = (function(_this) {
        return function() {
          var rev_map;
          if (_this.cancelled) {
            return;
          }
          rev_map = impl.clone(_this.update_manager._handle_version_map);
          return _this.cancel_fn = _this.update_manager.flob_client.await(rev_map, _this.update_manager._last_dslist_token, function(err, resp) {
            var cur_version, data, delta, handle, l, len1, next_version, ref, ref1, ref2;
            _this.cancel_fn = null;
            if (err) {
              if (err.status === 0) {
                console.log("await deltas failed (offline):", err);
                return setTimeout(do_one_poll, 10000);
              }
              if (err.status && ((500 <= (ref = err.status) && ref <= 599))) {
                console.log("server error:", err);
                return setTimeout(do_one_poll, 2000);
              }
              console.error("Got error in longpoll:", err);
              return setTimeout(do_one_poll, 10000);
            }
            if (resp.get_deltas != null) {
              ref1 = resp.get_deltas.deltas;
              for (handle in ref1) {
                data = ref1[handle];
                if (data.notfound != null) {
                  _this.update_manager._data_queue.push({
                    handle: handle,
                    notfound: data.notfound
                  });
                  delete _this.update_manager._handle_version_map[handle];
                } else if (data.deltas != null) {
                  if (data.role != null) {
                    _this.update_manager._data_queue.push({
                      handle: handle,
                      role: data.role
                    });
                  }
                  ref2 = data.deltas;
                  for (l = 0, len1 = ref2.length; l < len1; l++) {
                    delta = ref2[l];
                    _this.update_manager._data_queue.push({
                      handle: handle,
                      delta: delta
                    });
                  }
                  next_version = rev_map[handle] + data.deltas.length;
                  cur_version = _this.update_manager._handle_version_map[handle];
                  if (cur_version != null) {
                    _this.update_manager._handle_version_map[handle] = Math.max(cur_version, next_version);
                  }
                }
              }
            }
            if (resp.list_datastores != null) {
              _this.update_manager._last_dslist_token = resp.list_datastores.token;
              _this.update_manager._data_queue.push({
                dslist: resp.list_datastores
              });
            }
            return setTimeout(do_one_poll, 0);
          });
        };
      })(this);
      return do_one_poll();
    };

    return PendingPoll;

  })();

  FakeUpdateManager = (function() {
    function FakeUpdateManager(flob_client1) {
      this.flob_client = flob_client1;
      this._data_queue = null;
      this._handle_version_map = {};
      this._last_dslist_token = ".";
      this._pending_poll = null;
      this._running = false;
    }

    FakeUpdateManager.prototype.run = function(update_consumer) {
      this._data_queue = new ConsumptionQueue(update_consumer);
      this._running = true;
      return this._do_longpoll();
    };

    FakeUpdateManager.prototype.stop = function() {
      if (this._pending_poll) {
        return this._pending_poll.cancel();
      }
    };

    FakeUpdateManager.prototype.add_poll = function(handle, version) {
      var cur_version, new_version;
      assert(this._running, "update manager is not running");
      cur_version = this._handle_version_map[handle];
      new_version = version;
      if (cur_version != null) {
        new_version = Math.max(version, cur_version);
      }
      this._handle_version_map[handle] = new_version;
      return this._do_longpoll();
    };

    FakeUpdateManager.prototype.remove_poll = function(handle) {
      assert(this._running, "update manager is not running");
      if (!(handle in this._handle_version_map)) {
        return;
      }
      delete this._handle_version_map[handle];
      return this._do_longpoll();
    };

    FakeUpdateManager.prototype._do_longpoll = function() {
      assert(this._running, "update manager is not running");
      if (this._pending_poll) {
        this._pending_poll.cancel();
        this._pending_poll = null;
      }
      this._pending_poll = new PendingPoll(this);
      return this._pending_poll.poll();
    };

    return FakeUpdateManager;

  })();

  ObjectManager = (function() {
    function ObjectManager(update_manager, flob_client1, _dslist_listener_server, _dslist_listener_local) {
      this.update_manager = update_manager;
      this.flob_client = flob_client1;
      this._dslist_listener_server = _dslist_listener_server;
      this._dslist_listener_local = _dslist_listener_local;
      this.update_manager.run(this._handle_server_update.bind(this));
      this._cached_objects = {};
      this._handle_to_dsid_map = {};
    }

    ObjectManager.prototype.destroy = function() {
      var dsid;
      for (dsid in this._cached_objects) {
        this._cached_objects[dsid].close();
      }
      return this.update_manager.stop();
    };

    ObjectManager.prototype.getAllCachedUndeletedDatastoreIDs = function() {
      var datastore, dsid;
      return (function() {
        var ref, results1;
        ref = this._cached_objects;
        results1 = [];
        for (dsid in ref) {
          datastore = ref[dsid];
          if (!datastore.is_deleted()) {
            results1.push(dsid);
          }
        }
        return results1;
      }).call(this);
    };

    ObjectManager.prototype.getCachedDatastore = function(dsid) {
      return this._cached_objects[dsid];
    };

    ObjectManager.prototype._evict = function(handle) {
      var dsid, obj;
      dsid = this._handle_to_dsid_map[handle];
      if (dsid == null) {
        return;
      }
      delete this._handle_to_dsid_map[handle];
      if (dsid in this._cached_objects) {
        obj = this._cached_objects[dsid];
        obj.mark_deleted();
        if (obj.is_closed()) {
          delete this._cached_objects[dsid];
        }
      }
      return this.update_manager.remove_poll(handle);
    };

    ObjectManager.prototype.close = function(dsid) {
      var handle, obj;
      if (dsid in this._cached_objects) {
        handle = this._cached_objects[dsid].get_handle();
        obj = this._cached_objects[dsid];
        obj.close();
        if (obj.is_deleted()) {
          return delete this._cached_objects[dsid];
        }
      } else {
        throw new Error("Attempt to close unknown datastore: " + dsid);
      }
    };

    ObjectManager.prototype._handle_server_update = function(data, cb) {
      var dsid, flob_delta, handle;
      if (data.dslist) {
        if (this._dslist_listener_server) {
          this._dslist_listener_server(data.dslist);
        }
        return cb(null);
      } else {
        handle = data.handle;
        dsid = this._handle_to_dsid_map[handle];
        if (dsid == null) {
          console.log("unknown handle " + handle + " (maybe datastore was evicted)", data, this._handle_to_dsid_map, this._cached_objects);
          return cb(null);
        }
        if (data.delta == null) {
          if (data.notfound != null) {
            this._evict(handle);
          } else if (data.role != null) {
            if (this._cached_objects[dsid] != null) {
              this._cached_objects[dsid].role = data.role;
            }
          }
          return cb(null);
        }
        flob_delta = data.delta;
        return this._retrieve(dsid, handle, (function(_this) {
          return function(err, obj) {
            if (err) {
              return cb(err);
            }
            obj.receive_server_delta(flob_delta);
            return cb(null);
          };
        })(this));
      }
    };

    ObjectManager.prototype.open = function(dsid, handle, cb) {
      if (this._cached_objects[dsid]) {
        this._cached_objects[dsid].open();
      }
      return this._retrieve(dsid, handle, cb);
    };

    ObjectManager.prototype._retrieve = function(dsid, handle, cb) {
      var cached;
      cached = this._cached_objects[dsid];
      if (cached != null) {
        return cb(null, cached);
      }
      this._handle_to_dsid_map[handle] = dsid;
      return this.flob_client.get_snapshot(handle, (function(_this) {
        return function(err, resp) {
          var ds, obj, resolver;
          if (err != null) {
            return cb(err);
          }
          if (_this._cached_objects[dsid] != null) {
            return cb(null, _this._cached_objects[dsid]);
          }
          ds = DatastoreModel.from_get_snapshot_resp(resp);
          resolver = new DefaultResolver;
          obj = ManagedDatastore.fresh_managed_datastore(dsid, handle, resp.role, ds, resp.rev, resolver, _this.flob_client, _this._dslist_listener_local);
          _this.update_manager.add_poll(handle, obj.sync_state.get_server_rev());
          _this._cached_objects[dsid] = obj;
          return cb(null, obj);
        };
      })(this));
    };

    return ObjectManager;

  })();

  FieldOpTransformer = (function() {
    var LIST_TYPES, OP_TYPES, PRECEDENCE_FN_POOL, TYPE_NAMES, TYPE_RANK, coerce_num, compute_sum, copy, get_val_type, idx, is_less_than, is_list_less_than, is_wrapped_num, l, left_wins, len1, right_wins, swap, type_name;

    swap = function(fn) {
      assert(fn != null);
      return function(a, b) {
        var ref, x, y;
        ref = fn(b, a), x = ref[0], y = ref[1];
        return [y, x];
      };
    };

    TYPE_NAMES = ['null', 'bool', 'num', 'str', 'blob', 'ts', 'list'];

    TYPE_RANK = {};

    for (idx = l = 0, len1 = TYPE_NAMES.length; l < len1; idx = ++l) {
      type_name = TYPE_NAMES[idx];
      TYPE_RANK[type_name] = idx;
    }

    get_val_type = function(val) {
      if (val == null) {
        return 'null';
      }
      if (T.is_bool(val)) {
        return 'bool';
      }
      if ((val.I != null) || T.is_number(val)) {
        return 'num';
      }
      if (T.is_string(val)) {
        return 'str';
      }
      if (val.B != null) {
        return 'blob';
      }
      if (val.T != null) {
        return 'ts';
      }
      if (T.is_array(val)) {
        return 'list';
      }
      throw new Error("Unrecognized value " + val);
    };

    is_wrapped_num = function(val) {
      return (T.is_number(val)) || (val.I != null);
    };

    coerce_num = function(val) {
      if (val.I != null) {
        return parseInt(val.I);
      } else {
        return val;
      }
    };

    is_list_less_than = function(l1, l2) {
      var i, o, ref;
      for (i = o = 0, ref = l1.length; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        if (i >= l2.length) {
          return false;
        }
        if (is_less_than(l1[i], l2[i])) {
          return true;
        }
        if (is_less_than(l2[i], l1[i])) {
          return false;
        }
      }
      return l2.length > l1.length;
    };

    FieldOpTransformer._is_less_than = is_less_than = function(val1, val2) {
      var type1, type2;
      type1 = get_val_type(val1);
      type2 = get_val_type(val2);
      if (type1 !== type2) {
        return TYPE_RANK[type1] < TYPE_RANK[type2];
      }
      if (type1 === 'null') {
        return false;
      }
      if (type1 === 'bool') {
        return val2 && !val1;
      }
      if (type1 === 'num') {
        if ((val1.I != null) && (val2.I != null)) {
          return impl.int64_string_less_than(val1.I, val2.I);
        }
        return (coerce_num(val1)) < (coerce_num(val2));
      }
      if (type1 === 'str') {
        return val1 < val2;
      }
      if (type1 === 'blob') {
        return val1.B < val2.B;
      }
      if (type1 === 'ts') {
        return (parseInt(val1.T, 10)) < (parseInt(val2.T, 10));
      }
      if (type1 === 'list') {
        return is_list_less_than(val1, val2);
      }
      throw new Error("unknown type " + type1);
    };

    FieldOpTransformer._compute_sum = compute_sum = function(old_val, val1, val2) {
      var as_int, d1, result, two_to_63, two_to_64, two_to_64_rounded_down;
      as_int = (old_val.I != null) && (val1.I != null) && (val2.I != null);
      if (old_val.I != null) {
        old_val = parseInt(old_val.I);
      }
      if (val1.I != null) {
        val1 = parseInt(val1.I);
      }
      if (val2.I != null) {
        val2 = parseInt(val2.I);
      }
      two_to_63 = 9223372036854775808;
      two_to_64 = 18446744073709551616;
      two_to_64_rounded_down = 18446744073709550000;
      d1 = val1 - old_val;
      result = val2 + d1;
      if (as_int) {
        if (result >= two_to_63) {
          result -= two_to_64_rounded_down;
        }
        if (result < -two_to_63) {
          result += two_to_64_rounded_down;
        }
        result = {
          I: '' + result
        };
      }
      return result;
    };

    right_wins = function(op1, op2) {
      return [null, op2];
    };

    left_wins = function(op1, op2) {
      return [op1, null];
    };

    OP_TYPES = ['P', 'D', 'LC', 'LP', 'LI', 'LD', 'LM'];

    LIST_TYPES = ['LC', 'LP', 'LI', 'LD', 'LM'];

    FieldOpTransformer.copy = copy = function(op) {
      return FieldOp.from_array(JSON.parse(JSON.stringify(op)));
    };

    PRECEDENCE_FN_POOL = {
      "default": function(val1, val2) {
        return 'right';
      },
      remote: function(val1, val2) {
        return 'right';
      },
      local: function(val1, val2) {
        return 'left';
      },
      min: function(val1, val2) {
        if (is_less_than(val1, val2)) {
          return 'left';
        } else {
          return 'right';
        }
      },
      max: function(val1, val2) {
        if (is_less_than(val1, val2)) {
          return 'right';
        } else {
          return 'left';
        }
      },
      sum: function(val1, val2) {
        return 'right';
      }
    };

    function FieldOpTransformer(rule_name1) {
      var len2, len3, len4, len5, list_type, o, op_type, p, q, ref, z;
      this.rule_name = rule_name1 != null ? rule_name1 : 'default';
      this.precedence = PRECEDENCE_FN_POOL[this.rule_name];
      this._transforms = {};
      for (o = 0, len2 = OP_TYPES.length; o < len2; o++) {
        op_type = OP_TYPES[o];
        this._transforms[op_type] = {};
      }
      ref = ['P', 'D'];
      for (p = 0, len3 = ref.length; p < len3; p++) {
        op_type = ref[p];
        for (q = 0, len4 = LIST_TYPES.length; q < len4; q++) {
          list_type = LIST_TYPES[q];
          this._transforms[op_type][list_type] = left_wins;
          this._transforms[list_type][op_type] = right_wins;
        }
      }
      for (z = 0, len5 = LIST_TYPES.length; z < len5; z++) {
        list_type = LIST_TYPES[z];
        if (list_type === 'LC') {
          this._transforms['LC']['LC'] = (function(_this) {
            return function(op1, op2) {
              return [null, null];
            };
          })(this);
        } else {
          this._transforms['LC'][list_type] = right_wins;
          this._transforms[list_type]['LC'] = left_wins;
        }
      }
      this._transforms['P']['P'] = (function(_this) {
        return function(op1, op2) {
          var winner;
          winner = _this.precedence(op1.value, op2.value);
          return (winner === 'left' ? [op1, null] : [null, op2]);
        };
      })(this);
      this._transforms['P']['D'] = (function(_this) {
        return function(op1, op2) {
          var winner;
          winner = _this.precedence(op1.value, null);
          return (winner === 'left' ? [op1, null] : [null, op2]);
        };
      })(this);
      this._transforms['D']['P'] = (function(_this) {
        return function(op1, op2) {
          var winner;
          winner = _this.precedence(null, op2.value);
          return (winner === 'left' ? [op1, null] : [null, op2]);
        };
      })(this);
      this._transforms['D']['D'] = (function(_this) {
        return function(op1, op2) {
          var winner;
          winner = _this.precedence(null, null);
          return (winner === 'left' ? [op1, null] : [null, op2]);
        };
      })(this);
      this._transforms['LP']['LP'] = (function(_this) {
        return function(op1, op2) {
          var winner;
          if (op1.at !== op2.at) {
            return [op1, op2];
          }
          winner = _this.precedence(op1.value, op2.value);
          return (winner === 'left' ? [op1, null] : [null, op2]);
        };
      })(this);
      this._transforms['LP']['LI'] = (function(_this) {
        return function(op1, op2) {
          var new_op1;
          new_op1 = copy(op1);
          new_op1.at += (op2.before <= op1.at ? 1 : 0);
          return [new_op1, op2];
        };
      })(this);
      this._transforms['LP']['LD'] = (function(_this) {
        return function(op1, op2) {
          var new_op1;
          if (op1.at === op2.at) {
            return [null, op2];
          }
          new_op1 = copy(op1);
          new_op1.at -= (op2.at < op1.at ? 1 : 0);
          return [new_op1, op2];
        };
      })(this);
      this._transforms['LP']['LM'] = (function(_this) {
        return function(op1, op2) {
          var new_op1;
          new_op1 = copy(op1);
          if (op1.at === op2.from) {
            new_op1.at = op2.to;
          } else {
            new_op1.at -= (op2.from < new_op1.at ? 1 : 0);
            new_op1.at += (op2.to <= new_op1.at ? 1 : 0);
          }
          return [new_op1, op2];
        };
      })(this);
      this._transforms['LI']['LP'] = swap(this._transforms['LP']['LI']);
      this._transforms['LI']['LI'] = (function(_this) {
        return function(op1, op2) {
          var new_op1, new_op2, ref1;
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          if (op1.before < op2.before) {
            new_op2.before += 1;
          } else {
            new_op1.before += 1;
          }
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LI']['LD'] = (function(_this) {
        return function(op1, op2) {
          var new_op1, new_op2, ref1;
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          new_op1.before -= (op2.at < op1.before ? 1 : 0);
          new_op2.at += (op1.before <= op2.at ? 1 : 0);
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LI']['LM'] = (function(_this) {
        return function(op1, op2) {
          var new_ins, new_op1, new_op2, ref1;
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          if (op1.before === op2.to + 1 && op2.from <= op2.to) {
            return [op1, op2];
          }
          if (op1.before === op2.to && op2.from > op2.to) {
            new_op1.before++;
            new_op2.from++;
            return [new_op1, new_op2];
          }
          new_ins = (op2.from < op1.before ? op1.before - 1 : op1.before);
          new_op2.from += (op1.before <= op2.from ? 1 : 0);
          new_op1.before = (op2.to < new_ins ? new_ins + 1 : new_ins);
          new_op2.to += (new_ins <= op2.to ? 1 : 0);
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LD']['LP'] = swap(this._transforms['LP']['LD']);
      this._transforms['LD']['LI'] = swap(this._transforms['LI']['LD']);
      this._transforms['LD']['LD'] = (function(_this) {
        return function(op1, op2) {
          var new_op1, new_op2, ref1;
          if (op1.at === op2.at) {
            return [null, null];
          }
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          if (op1.at < op2.at) {
            new_op2.at -= 1;
          } else {
            new_op1.at -= 1;
          }
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LD']['LM'] = (function(_this) {
        return function(op1, op2) {
          var new_op1, new_op2, ref1;
          if (op1.at === op2.from) {
            new_op1 = copy(op1);
            new_op1.at = op2.to;
            return [new_op1, null];
          }
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          new_op1.at -= (op2.from < new_op1.at ? 1 : 0);
          new_op1.at += (op2.to <= new_op1.at ? 1 : 0);
          new_op2.to += (new_op2.from < new_op2.to ? 1 : 0);
          new_op2.from -= (op1.at < new_op2.from ? 1 : 0);
          new_op2.to -= (op1.at < new_op2.to ? 1 : 0);
          new_op2.to -= (new_op2.from < new_op2.to ? 1 : 0);
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LM']['LP'] = swap(this._transforms['LP']['LM']);
      this._transforms['LM']['LI'] = (function(_this) {
        return function(op1, op2) {
          var new_ins, new_op1, new_op2, ref1;
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          if (op2.before === op1.to + 1 && op1.from <= op1.to) {
            return [op1, op2];
          }
          if (op2.before === op1.to && op1.from > op1.to) {
            new_op1.from++;
            new_op1.to++;
            return [new_op1, new_op2];
          }
          new_ins = (op1.from < op2.before ? op2.before - 1 : op2.before);
          new_op1.from += (op2.before <= op1.from ? 1 : 0);
          new_op2.before = (op1.to < new_ins ? new_ins + 1 : new_ins);
          new_op1.to += (new_ins <= op1.to ? 1 : 0);
          return [new_op1, new_op2];
        };
      })(this);
      this._transforms['LM']['LD'] = swap(this._transforms['LD']['LM']);
      this._transforms['LM']['LM'] = (function(_this) {
        return function(op1, op2) {
          var new_from1, new_from2, new_op1, new_op2, new_to1, new_to2, ref1, ref2, ref3, ref4, ref5;
          if (op1.from === op2.from) {
            if (op1.to === op2.to) {
              return [null, null];
            }
            if (op2.from === op2.to) {
              return [op1, op2];
            }
            new_op2 = copy(op2);
            new_op2.from = op1.to;
            return [null, new_op2];
          }
          if (op1.to === op1.from) {
            new_op1 = copy(op1);
            new_op1.from += (op2.to <= op1.from) - (op2.from < op1.from);
            if (op1.from === op2.to && op2.from < op2.to) {
              new_op1.from--;
            }
            new_op1.to = new_op1.from;
            return [new_op1, op2];
          }
          if (op2.to === op2.from) {
            new_op2 = copy(op2);
            new_op2.from += (op1.to <= op2.from) - (op1.from < op2.from);
            new_op2.to = new_op2.from;
            return [op1, new_op2];
          }
          ref1 = [copy(op1), copy(op2)], new_op1 = ref1[0], new_op2 = ref1[1];
          if (op1.to === op2.to && op1.from > op1.to && op2.from > op2.to) {
            new_op1.to++;
            if (op2.from > op1.from) {
              new_op1.from++;
            } else {
              new_op2.from++;
            }
            return [new_op1, new_op2];
          }
          if (op1.from === op2.to && op2.from === op1.to && op1.from < op1.to) {
            new_op2.from--;
            new_op1.from++;
            return [new_op1, new_op2];
          }
          if (op1.from > op1.to && op2.from < op2.to && op2.to + 1 === op1.to) {
            return [op1, op2];
          }
          ref2 = [op1.to, op1.from], new_to1 = ref2[0], new_from1 = ref2[1];
          new_to1 += (op1.from < new_to1 ? 1 : 0);
          new_to1 -= (op2.from < new_to1 ? 1 : 0);
          new_to1 += (op2.to < new_to1 ? 1 : 0);
          new_from1 -= (op2.from < new_from1 ? 1 : 0);
          new_from1 += (op2.to <= new_from1 ? 1 : 0);
          new_to1 -= (new_from1 < new_to1 ? 1 : 0);
          ref3 = [op2.to, op2.from], new_to2 = ref3[0], new_from2 = ref3[1];
          new_to2 += (op2.from < new_to2 ? 1 : 0);
          new_to2 -= (op1.from < new_to2 ? 1 : 0);
          new_to2 += (op1.to <= new_to2 ? 1 : 0);
          new_from2 -= (op1.from < new_from2 ? 1 : 0);
          new_from2 += (op1.to <= new_from2 ? 1 : 0);
          new_to2 -= (new_from2 < new_to2 ? 1 : 0);
          ref4 = [new_to1, new_from1], new_op1.to = ref4[0], new_op1.from = ref4[1];
          ref5 = [new_to2, new_from2], new_op2.to = ref5[0], new_op2.from = ref5[1];
          return [new_op1, new_op2];
        };
      })(this);
    }

    FieldOpTransformer.prototype.transform = function(op1, op2, old_val) {
      var new_op1, new_op2, new_val, ret, undo_extra;
      if (old_val == null) {
        old_val = null;
      }
      if (this.rule_name === 'sum' && op1.tag() === 'P' && op2.tag() === 'P') {
        if (old_val == null) {
          old_val = {
            I: '0'
          };
        }
        if ((is_wrapped_num(old_val)) && (is_wrapped_num(op1.value)) && (is_wrapped_num(op2.value))) {
          new_val = compute_sum(old_val, op1.value, op2.value);
          new_op1 = new_op2 = FieldOp.from_array(['P', new_val]);
          return [new_op1, new_op2, op2.value];
        }
      }
      ret = this._transforms[op1.tag()][op2.tag()](op1, op2);
      undo_extra = (function() {
        switch (op2.tag()) {
          case 'P':
            return op2.value;
          case 'D':
            return null;
          default:
            return {
              L: true
            };
        }
      })();
      ret.push(undo_extra);
      return ret;
    };

    return FieldOpTransformer;

  })();

  impl.FieldOpTransformer = FieldOpTransformer;

  ChangeTransformer = (function() {
    var TRANSFORMER_POOL, copy_data, l, len1, ref, rule_name, same_row, swap;

    TRANSFORMER_POOL = {};

    ref = ['default', 'local', 'remote', 'min', 'max', 'sum'];
    for (l = 0, len1 = ref.length; l < len1; l++) {
      rule_name = ref[l];
      TRANSFORMER_POOL[rule_name] = new FieldOpTransformer(rule_name);
    }

    swap = function(fn) {
      assert(fn != null);
      return function(a, b) {
        var ref1, x, y;
        ref1 = fn(b, a), x = ref1[0], y = ref1[1];
        return [y, x];
      };
    };

    copy_data = function(val) {
      return (val instanceof Array ? val.slice() : val);
    };

    same_row = function(o1, o2) {
      return o1.tid === o2.tid && o1.rowid === o2.rowid;
    };

    ChangeTransformer.is_no_op = function(change) {
      var field_op, k, ref1;
      if (change.tag() !== 'U') {
        return false;
      }
      ref1 = change.updates;
      for (k in ref1) {
        field_op = ref1[k];
        return false;
      }
      return true;
    };

    ChangeTransformer.compact = function(ops_list) {
      var compacted, len2, o, op;
      compacted = [];
      for (o = 0, len2 = ops_list.length; o < len2; o++) {
        op = ops_list[o];
        if (!this.is_no_op(op)) {
          compacted.push(op);
        }
      }
      return compacted;
    };

    function ChangeTransformer() {
      this._transform_rules = {};
      this._default_transformer = new FieldOpTransformer;
    }

    ChangeTransformer.prototype.set_field_transformer = function(tid, field_name, rule_name) {
      var base1;
      if ((base1 = this._transform_rules)[tid] == null) {
        base1[tid] = {};
      }
      return this._transform_rules[tid][field_name] = TRANSFORMER_POOL[rule_name];
    };

    ChangeTransformer.prototype.get_field_transformer = function(tid, field_name) {
      var ref1;
      if (!(tid in this._transform_rules)) {
        return TRANSFORMER_POOL["default"];
      }
      return (ref1 = this._transform_rules[tid][field_name]) != null ? ref1 : this._default_transformer;
    };

    ChangeTransformer.prototype.transform_ii = function(i1, i2) {
      var make_update, u1, u2;
      if (!same_row(i1, i2)) {
        return [[i1], [i2]];
      }
      make_update = function(ins) {
        var chg, k, ref1, updates, v;
        updates = {};
        ref1 = ins.fields;
        for (k in ref1) {
          v = ref1[k];
          updates[k] = FieldOp.from_array(['P', copy_data(v)]);
        }
        chg = Change.from_array(['U', ins.tid, ins.rowid, updates]);
        chg.undo_extra = {};
        return chg;
      };
      u1 = make_update(i1);
      u2 = make_update(i2);
      return this.transform_uu(u1, u2);
    };

    ChangeTransformer.prototype.transform_iu = function(i, u) {
      if (!same_row(i, u)) {
        return [[i], [u]];
      }
      return assert(false, "Couldn't have updated a row that hasn't been inserted yet!");
    };

    ChangeTransformer.prototype.transform_id = function(i, d) {
      if (!same_row(i, d)) {
        return [[i], [d]];
      }
      return assert(false, "Couldn't have deleted a row that hasn't been inserted yet!");
    };

    ChangeTransformer.prototype.transform_ui = swap(ChangeTransformer.prototype.transform_iu);

    ChangeTransformer.prototype.transform_uu = function(u1, u2) {
      var field_op1, field_op2, k, new_op1, new_op2, new_u1, new_u2, new_undo_extra1, new_updates1, new_updates2, old_val, ref1, ref2, ref3, ref4, ref5, ref6, transformer, undo_extra;
      if (!same_row(u1, u2)) {
        return [[u1], [u2]];
      }
      ref1 = [{}, {}], new_updates1 = ref1[0], new_updates2 = ref1[1];
      new_undo_extra1 = {};
      ref2 = u1.updates;
      for (k in ref2) {
        field_op1 = ref2[k];
        if (!(k in u2.updates)) {
          new_updates1[k] = field_op1;
          new_undo_extra1[k] = (ref3 = u1.undo_extra[k]) != null ? ref3 : null;
          continue;
        }
        field_op2 = u2.updates[k];
        old_val = (ref4 = u1.undo_extra[k]) != null ? ref4 : null;
        transformer = this.get_field_transformer(u1.tid, k);
        ref5 = transformer.transform(field_op1, field_op2, old_val), new_op1 = ref5[0], new_op2 = ref5[1], undo_extra = ref5[2];
        if (new_op1 != null) {
          new_updates1[k] = new_op1;
          new_undo_extra1[k] = undo_extra != null ? undo_extra : null;
        }
        if (new_op2 != null) {
          new_updates2[k] = new_op2;
        }
      }
      ref6 = u2.updates;
      for (k in ref6) {
        field_op2 = ref6[k];
        if (!(k in u1.updates)) {
          new_updates2[k] = field_op2;
        }
      }
      new_u1 = Change.from_array(['U', u1.tid, u1.rowid, new_updates1]);
      new_u1.undo_extra = new_undo_extra1;
      new_u2 = Change.from_array(['U', u2.tid, u2.rowid, new_updates2]);
      return [[new_u1], [new_u2]];
    };

    ChangeTransformer.prototype.transform_ud = function(u, d) {
      if (!same_row(u, d)) {
        return [[u], [d]];
      }
      return [[], [d]];
    };

    ChangeTransformer.prototype.transform_di = swap(ChangeTransformer.prototype.transform_id);

    ChangeTransformer.prototype.transform_du = swap(ChangeTransformer.prototype.transform_ud);

    ChangeTransformer.prototype.transform_dd = function(d1, d2) {
      if (!same_row(d1, d2)) {
        return [[d1], [d2]];
      }
      return [[], []];
    };

    return ChangeTransformer;

  })();

  impl.ChangeTransformer = ChangeTransformer;

  DefaultResolver = (function() {
    function DefaultResolver() {
      this._change_transformer = new ChangeTransformer;
    }

    DefaultResolver.prototype.add_resolution_rule = function(tid, field_name, rule_name) {
      return this._change_transformer.set_field_transformer(tid, field_name, rule_name);
    };

    DefaultResolver.prototype._transform_one = function(local, server) {
      var change_to_letter, new_local, new_server, ref, trans_fn_name;
      change_to_letter = function(c) {
        switch (c.tag()) {
          case 'I':
            return 'i';
          case 'U':
            return 'u';
          case 'D':
            return 'd';
          default:
            throw new Error("unrecognized op type " + (c.tag()));
        }
      };
      trans_fn_name = 'transform_' + (change_to_letter(local)) + (change_to_letter(server));
      ref = this._change_transformer[trans_fn_name](local, server), new_local = ref[0], new_server = ref[1];
      new_local = ChangeTransformer.compact(new_local);
      new_server = ChangeTransformer.compact(new_server);
      return [new_local, new_server];
    };

    DefaultResolver.prototype._transform_list = function(local_ops, server_ops) {
      var first_local, first_server, l, len1, len2, local_rest, new_local, new_server, o, op, ref, ref1, ref2, server_rest;
      if (local_ops.length === 0) {
        return [[], server_ops];
      }
      if (server_ops.length === 0) {
        return [local_ops, []];
      }
      first_local = local_ops[0];
      first_server = server_ops[0];
      ref = this._transform_one(first_local, first_server), new_local = ref[0], new_server = ref[1];
      ref1 = this._transform_list(local_ops.slice(1), new_server), local_rest = ref1[0], new_server = ref1[1];
      for (l = 0, len1 = local_rest.length; l < len1; l++) {
        op = local_rest[l];
        new_local.push(op);
      }
      ref2 = this._transform_list(new_local, server_ops.slice(1)), new_local = ref2[0], server_rest = ref2[1];
      for (o = 0, len2 = server_rest.length; o < len2; o++) {
        op = server_rest[o];
        new_server.push(op);
      }
      return [new_local, new_server];
    };

    DefaultResolver.prototype._resolve = function(local_op_batches, server_ops) {
      var l, len1, local_batch, new_local_batches, op_batch, ops_to_apply, ref;
      ops_to_apply = server_ops.slice();
      new_local_batches = [];
      for (l = 0, len1 = local_op_batches.length; l < len1; l++) {
        op_batch = local_op_batches[l];
        ref = this._transform_list(op_batch, ops_to_apply), local_batch = ref[0], ops_to_apply = ref[1];
        new_local_batches.push(local_batch);
      }
      return [new_local_batches, ops_to_apply];
    };

    DefaultResolver.prototype.resolve = function(local_deltas, server_deltas) {
      var aa, ab, affected_records, batch, c, change, change_batch, change_cpy, changes_to_apply, delta, idx, l, len1, len2, len3, len4, len5, len6, len7, local_change_batches, new_local_change_batches, o, p, q, ref, ref1, ref2, ret, server_changes, undo_extras, z;
      local_change_batches = [];
      for (l = 0, len1 = local_deltas.length; l < len1; l++) {
        delta = local_deltas[l];
        batch = [];
        ref = delta.changes;
        for (idx = o = 0, len2 = ref.length; o < len2; idx = ++o) {
          change = ref[idx];
          change_cpy = Change.from_array(JSON.parse(JSON.stringify(change)));
          change_cpy.undo_extra = impl.clone(delta.undo_extras[idx]);
          batch.push(change_cpy);
        }
        local_change_batches.push(batch);
      }
      server_changes = [];
      for (p = 0, len3 = server_deltas.length; p < len3; p++) {
        delta = server_deltas[p];
        ref1 = delta.changes;
        for (q = 0, len4 = ref1.length; q < len4; q++) {
          c = ref1[q];
          server_changes.push(c);
        }
      }
      ref2 = this._resolve(local_change_batches, server_changes), new_local_change_batches = ref2[0], changes_to_apply = ref2[1];
      ret = [];
      for (idx = z = 0, len5 = new_local_change_batches.length; z < len5; idx = ++z) {
        change_batch = new_local_change_batches[idx];
        undo_extras = (function() {
          var aa, len6, results1;
          results1 = [];
          for (aa = 0, len6 = change_batch.length; aa < len6; aa++) {
            change = change_batch[aa];
            results1.push(null);
          }
          return results1;
        })();
        for (aa = 0, len6 = change_batch.length; aa < len6; aa++) {
          change = change_batch[aa];
          delete change.undo_extra;
        }
        if (change_batch.length > 0) {
          ret.push(new LocalDelta(change_batch, undo_extras));
        }
      }
      affected_records = {};
      for (ab = 0, len7 = changes_to_apply.length; ab < len7; ab++) {
        c = changes_to_apply[ab];
        if (!(c.tid in affected_records)) {
          affected_records[c.tid] = {};
        }
        affected_records[c.tid][c.rowid] = true;
      }
      return {
        rebased_deltas: ret,
        affected_records: affected_records
      };
    };

    return DefaultResolver;

  })();

  impl.DefaultResolver = DefaultResolver;

  SyncQueue = (function() {
    function SyncQueue() {
      this._waiting = [];
      this._running = false;
    }

    SyncQueue.prototype._run_next = function() {
      var next;
      if (this._running) {
        return;
      }
      if (this._waiting.length > 0) {
        next = this._waiting[0];
        this._waiting.shift();
        this._running = true;
        next();
      }
    };

    SyncQueue.prototype.request = function(cb) {
      this._waiting.push(cb);
      return this._run_next();
    };

    SyncQueue.prototype.finish = function() {
      this._running = false;
      return setTimeout(this._run_next.bind(this), 0);
    };

    return SyncQueue;

  })();

  ConsumptionQueue = (function() {
    function ConsumptionQueue(consumer) {
      this.consumer = consumer;
      this.items = [];
      this.sync_queue = new SyncQueue;
    }

    ConsumptionQueue.prototype.consume = function() {
      return this.sync_queue.request((function(_this) {
        return function() {
          var item;
          if (_this.items.length === 0) {
            return _this.sync_queue.finish();
          }
          item = _this.items.shift();
          return _this.consumer(item, function(err) {
            if (err) {
              throw err;
            }
            _this.sync_queue.finish();
            return _this.consume();
          });
        };
      })(this));
    };

    ConsumptionQueue.prototype.push = function(item) {
      this.items.push(item);
      return this.consume();
    };

    ConsumptionQueue.prototype.run = function() {
      return this.consume();
    };

    return ConsumptionQueue;

  })();

  impl.clone = function(x) {
    var e, k, l, len1, out, results1, v;
    if (x instanceof Array) {
      results1 = [];
      for (l = 0, len1 = x.length; l < len1; l++) {
        e = x[l];
        results1.push(impl.clone(e));
      }
      return results1;
    } else if ((x != null) && typeof x === 'object') {
      out = {};
      for (k in x) {
        v = x[k];
        out[k] = impl.clone(v);
      }
      return out;
    } else {
      return x;
    }
  };

  impl.WEB64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

  impl.randomElement = function(s) {
    return s[Math.floor(Math.random() * s.length)];
  };

  impl.randomWeb64String = function(len) {
    var i;
    return ((function() {
      var l, ref, results1;
      results1 = [];
      for (i = l = 0, ref = len; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results1.push(impl.randomElement(impl.WEB64_ALPHABET));
      }
      return results1;
    })()).join("");
  };

  impl.uint8ArrayFromBase64String = function(s) {
    var byteString, i, l, len, out, ref;
    s = s.replace(/-/g, '+').replace(/_/g, '/');
    byteString = Dropbox.Util.atob(s);
    len = byteString.length;
    out = new Uint8Array(len);
    for (i = l = 0, ref = len; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      out[i] = byteString.charCodeAt(i);
    }
    return out;
  };

  impl.dbase64FromBase64 = function(s) {
    return s.replace(/[+]/g, '-').replace(/[\/]/g, '_').replace(/[\=]+$/g, '');
  };

  impl.base64StringFromUint8Array = function(bytes) {
    var byte, byteString, l, len1, s;
    byteString = "";
    for (l = 0, len1 = bytes.length; l < len1; l++) {
      byte = bytes[l];
      byteString += String.fromCharCode(byte);
    }
    s = Dropbox.Util.btoa(byteString);
    return impl.dbase64FromBase64(s);
  };

  impl.INT64_TAG = 'dbxInt64';

  impl.isInt64 = function(x) {
    var tag;
    if (!(x && typeof x === 'object' && x.constructor === Number && isFinite(x))) {
      return false;
    }
    tag = x[impl.INT64_TAG];
    if (!((T.is_string(tag)) && (tag === '0' || impl.nonzero_int64_approximate_regex.test(tag)))) {
      return false;
    }
    return true;
  };

  impl.validateInt64 = function(x) {
    var parsed, tag;
    if (!x && (typeof x === 'object' && x.constructor === Number && isFinite(x))) {
      throw new Error("Not a finite boxed number: " + x);
    }
    tag = x[impl.INT64_TAG];
    if (!((T.is_string(tag)) && (tag === '0' || impl.nonzero_int64_approximate_regex.test(tag)))) {
      throw new Error("Missing or invalid tag in int64: " + tag);
    }
    parsed = parseInt(tag, 10);
    if (parsed !== Number(x)) {
      throw new Error("Tag in int64 does not match value " + (Number(x)) + ": " + tag);
    }
    return x;
  };

  impl.toDsValue = function(x, allowArray) {
    var t, y;
    if (allowArray == null) {
      allowArray = true;
    }
    if ((x === null) || (typeof x === 'undefined')) {
      throw new Error("Bad value: " + x);
    } else if (T.is_string(x)) {
      return x;
    } else if (T.is_bool(x)) {
      return x;
    } else if (T.is_number(x)) {
      if (x[impl.INT64_TAG] != null) {
        impl.validateInt64(x);
        return {
          I: x[impl.INT64_TAG]
        };
      } else if (isFinite(x)) {
        return x;
      } else if (isNaN(x)) {
        return {
          N: "nan"
        };
      } else if ((Number(x)) === Infinity) {
        return {
          N: "+inf"
        };
      } else if ((Number(x)) === -Infinity) {
        return {
          N: "-inf"
        };
      } else {
        throw new Error("Unexpected number: " + x);
      }
    } else if (T.is_array(x)) {
      if (!allowArray) {
        throw new Error("Nested array not allowed: " + (JSON.stringify(x)));
      } else {
        return (function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = x.length; l < len1; l++) {
            y = x[l];
            results1.push(impl.toDsValue(y, false));
          }
          return results1;
        })();
      }
    } else if (T.is_date(x)) {
      t = Math.round(x.getTime());
      return {
        T: "" + t
      };
    } else if (T.isUint8Array(x)) {
      return {
        B: impl.base64StringFromUint8Array(x)
      };
    } else {
      throw new Error("Unexpected value: " + (T.safe_to_string(x)));
    }
  };

  impl.fromDsValue = function(datastore, record, fieldName, x) {
    if (T.is_string(x)) {
      return x;
    } else if (T.is_bool(x)) {
      return x;
    } else if (T.is_number(x)) {
      return x;
    } else if (T.is_array(x)) {
      return new Dropbox.Datastore.List(datastore, record, fieldName);
    } else {
      if (typeof x !== 'object') {
        throw new Error("Unexpected value: " + x);
      }
      if (x.I != null) {
        return Dropbox.Datastore.int64(x.I);
      } else if (x.N != null) {
        switch (x.N) {
          case 'nan':
            return NaN;
          case '+inf':
            return Infinity;
          case '-inf':
            return -Infinity;
          default:
            throw new Error("Unexpected object: " + (JSON.stringify(x)));
        }
      } else if (x.B != null) {
        return impl.uint8ArrayFromBase64String(x.B);
      } else if (x.T != null) {
        return new Date(parseInt(x.T, 10));
      } else {
        throw new Error("Unexpected object: " + (JSON.stringify(x)));
      }
    }
  };

  impl.matchDsValues = function(pattern, data) {
    var fieldEq, fieldMatch, k, test, v;
    fieldMatch = function(field_pattern, field_data) {
      if (field_pattern == null) {
        throw new Error("Unexpected object: " + field_pattern);
      }
      if (field_data == null) {
        return false;
      }
      return fieldEq(field_pattern, field_data);
    };
    fieldEq = function(jsval, dsval) {
      var i, l, o, ref, ref1, ref2;
      impl.toDsValue(jsval);
      if ((T.is_string(jsval)) && (T.is_string(dsval))) {
        return (String(jsval)) === (String(dsval));
      } else if ((T.is_bool(jsval)) && (T.is_bool(dsval))) {
        if ((typeof jsval) === "object") {
          jsval = jsval.valueOf();
        }
        if ((typeof dsval) === "object") {
          dsval = dsval.valueOf();
        }
        return (Boolean(jsval)) === (Boolean(dsval));
      } else if ((T.is_number(jsval)) && ((T.is_number(dsval)) || (dsval.N != null) || (dsval.I != null))) {
        dsval = impl.fromDsValue(void 0, void 0, void 0, dsval);
        if (jsval[impl.INT64_TAG] && dsval[impl.INT64_TAG]) {
          ref = [Dropbox.Datastore.int64(jsval), Dropbox.Datastore.int64(dsval)], jsval = ref[0], dsval = ref[1];
          return (String(jsval[impl.INT64_TAG])) === (String(dsval[impl.INT64_TAG]));
        } else if ((isNaN(jsval)) && (isNaN(dsval))) {
          return true;
        } else {
          return (Number(jsval)) === (Number(dsval));
        }
      } else if ((T.is_array(jsval)) && (T.is_array(dsval))) {
        if (jsval.length !== dsval.length) {
          return false;
        }
        for (i = l = 0, ref1 = jsval.length - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
          if (!fieldMatch(jsval[i], dsval[i])) {
            return false;
          }
        }
        return true;
      } else if ((T.is_date(jsval)) && ((T.is_date(dsval)) || (dsval.T != null))) {
        if (dsval.T != null) {
          dsval = impl.fromDsValue(void 0, void 0, void 0, dsval);
        }
        return (jsval - 0) === (dsval - 0);
      } else if ((T.isUint8Array(jsval)) && ((T.isUint8Array(dsval)) || (dsval.B != null))) {
        if (dsval.B != null) {
          dsval = impl.fromDsValue(void 0, void 0, void 0, dsval);
        }
        if (jsval.length !== dsval.length) {
          return false;
        }
        for (i = o = 0, ref2 = jsval.length - 1; 0 <= ref2 ? o <= ref2 : o >= ref2; i = 0 <= ref2 ? ++o : --o) {
          if (jsval[i] !== dsval[i]) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    };
    for (k in pattern) {
      v = pattern[k];
      test = fieldMatch(v, data[k]);
      if (!test) {
        return test;
      }
    }
    return true;
  };

  RecordCache = (function() {
    function RecordCache(_datastore) {
      this._datastore = _datastore;
      this._cache = {};
    }

    RecordCache.prototype.get = function(tid, rid) {
      if (this._cache[tid] == null) {
        return null;
      }
      return this._cache[tid][rid];
    };

    RecordCache.prototype.getOrCreate = function(tid, rid) {
      var record;
      if (this._cache[tid] == null) {
        this._cache[tid] = {};
      }
      record = this._cache[tid][rid];
      if (record == null) {
        record = this._cache[tid][rid] = new Dropbox.Datastore.Record(this._datastore, tid, rid);
      }
      return record;
    };

    RecordCache.prototype.remove = function(tid, rid) {
      delete this._cache[tid][rid];
      if (T.is_empty(this._cache[tid])) {
        delete this._cache[tid];
      }
      return void 0;
    };

    return RecordCache;

  })();

  EventManager = (function() {
    function EventManager() {
      this._registered_handlers = [];
    }

    EventManager.prototype.register = function(src, handler) {
      src.addListener(handler);
      this._registered_handlers.push([src, handler]);
      return void 0;
    };

    EventManager.prototype.unregister_all = function() {
      var handler, l, len1, ref, ref1, src;
      ref = this._registered_handlers;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        ref1 = ref[l], src = ref1[0], handler = ref1[1];
        src.removeListener(handler);
      }
      return void 0;
    };

    return EventManager;

  })();

  Dropbox.Datastore.DatastoreInfo = (function() {
    function DatastoreInfo(_dsid, _handle, _info_record_data, _role) {
      this._dsid = _dsid;
      this._handle = _handle;
      this._info_record_data = _info_record_data;
      this._role = _role;
    }

    DatastoreInfo.prototype.toString = function() {
      return "Datastore.DatastoreInfo(" + this._dsid + " " + (JSON.stringify(this._info_record_data || {})) + " " + (this.getEffectiveRole()) + ")";
    };

    DatastoreInfo.prototype.getId = function() {
      return this._dsid;
    };

    DatastoreInfo.prototype.isShareable = function() {
      return this._dsid[0] === '.';
    };

    DatastoreInfo.prototype.getHandle = function() {
      return this._handle;
    };

    DatastoreInfo.prototype.getTitle = function() {
      var ref;
      if (((ref = this._info_record_data) != null ? ref.title : void 0) == null) {
        return null;
      }
      return this._info_record_data.title;
    };

    DatastoreInfo.prototype.getModifiedTime = function() {
      var ref;
      if (((ref = this._info_record_data) != null ? ref.mtime : void 0) == null) {
        return null;
      }
      return this._info_record_data.mtime;
    };

    DatastoreInfo.prototype.getEffectiveRole = function() {
      if (!(this.isShareable() && (this._role != null))) {
        return Dropbox.Datastore.OWNER;
      }
      return Dropbox.Datastore._roleFromInt(this._role);
    };

    DatastoreInfo.prototype.isWritable = function() {
      var role;
      role = this.getEffectiveRole();
      return role === Dropbox.Datastore.OWNER || role === Dropbox.Datastore.EDITOR;
    };

    return DatastoreInfo;

  })();

  Dropbox.Datastore.DatastoreListChanged = (function() {
    function DatastoreListChanged(_dsinfos) {
      this._dsinfos = _dsinfos;
    }

    DatastoreListChanged.prototype.toString = function() {
      return "Datastore.DatastoreListChanged(" + this._dsinfos.length + " datastores)";
    };

    DatastoreListChanged.prototype.getDatastoreInfos = function() {
      return this._dsinfos;
    };

    return DatastoreListChanged;

  })();

  Dropbox.Datastore.impl.EventSourceWithInitialData = (function(superClass) {
    extend(EventSourceWithInitialData, superClass);

    function EventSourceWithInitialData(options1) {
      this.options = options1;
      EventSourceWithInitialData.__super__.constructor.call(this, this.options);
      this._have_event = false;
      this._last_event = null;
      this._listenersChanged = new Dropbox.Util.EventSource;
    }

    EventSourceWithInitialData.prototype._clearLastEvent = function() {
      this._have_event = false;
      return this._last_event = null;
    };

    EventSourceWithInitialData.prototype.addListener = function(listener) {
      var ret;
      ret = EventSourceWithInitialData.__super__.addListener.call(this, listener);
      if (this._have_event) {
        listener(this._last_event);
      }
      this._listenersChanged.dispatch(this._listeners);
      return ret;
    };

    EventSourceWithInitialData.prototype.removeListener = function(listener) {
      var ret;
      ret = EventSourceWithInitialData.__super__.removeListener.call(this, listener);
      this._listenersChanged.dispatch(this._listeners);
      return ret;
    };

    EventSourceWithInitialData.prototype.dispatch = function(event) {
      this._last_event = event;
      this._have_event = true;
      return EventSourceWithInitialData.__super__.dispatch.call(this, event);
    };

    return EventSourceWithInitialData;

  })(Dropbox.Util.EventSource);

  DEFAULT_DATASTORE_ID = 'default';

  Dropbox.Datastore.DatastoreManager = (function() {
    DatastoreManager.prototype.datastoreListChanged = null;

    function DatastoreManager(client) {
      if (!client.isAuthenticated()) {
        throw new Error("DatastoreManager requires an authenticated Dropbox.Client!");
      }
      this.datastoreListChanged = new Dropbox.Datastore.impl.EventSourceWithInitialData;
      this._flob_client = new FlobClient(client);
      this._lastListDsServerResponse = null;
      this._obj_manager = new ObjectManager(new FakeUpdateManager(this._flob_client), this._flob_client, ((function(_this) {
        return function(data) {
          return _this._handleRemoteDslistUpdate(data);
        };
      })(this)), ((function(_this) {
        return function() {
          return _this._handleLocalDslistUpdate();
        };
      })(this)));
    }

    DatastoreManager.prototype.close = function() {
      return this._obj_manager.destroy();
    };

    DatastoreManager.prototype.toString = function() {
      return "Datastore.DatastoreManager()";
    };

    DatastoreManager.prototype._dispatchDslistEvent = function() {
      var server_resp;
      server_resp = this._lastListDsServerResponse || new ListDatastoresResponse({
        datastores: [],
        token: "dummy"
      });
      this.datastoreListChanged.dispatch(new Dropbox.Datastore.DatastoreListChanged(this._getOverlaidDatastoreInfosFromListResponse(server_resp)));
      return void 0;
    };

    DatastoreManager.prototype._handleLocalDslistUpdate = function() {
      this._dispatchDslistEvent();
      return void 0;
    };

    DatastoreManager.prototype._handleRemoteDslistUpdate = function(data) {
      this._lastListDsServerResponse = data;
      this._dispatchDslistEvent();
      return void 0;
    };

    DatastoreManager.prototype._getOverlaidDatastoreInfo = function(dsid, dsResponse) {
      var cachedDatastore, field, handle, infoFields, ref, remoteInfo, role, v2, value;
      cachedDatastore = this._obj_manager.getCachedDatastore(dsid);
      remoteInfo = (dsResponse != null ? dsResponse.info : void 0) || {};
      if (cachedDatastore == null) {
        infoFields = impl.clone(remoteInfo);
      } else if ((dsResponse == null) || dsResponse.rev < cachedDatastore.sync_state.get_server_rev()) {
        infoFields = cachedDatastore.datastore_model.getLocalInfoData();
      } else {
        infoFields = cachedDatastore.datastore_model.updateDatastoreInfo(remoteInfo);
      }
      for (field in infoFields) {
        value = infoFields[field];
        infoFields[field] = T.is_array(value) ? (function() {
          var l, len1, results1;
          results1 = [];
          for (l = 0, len1 = value.length; l < len1; l++) {
            v2 = value[l];
            results1.push(impl.fromDsValue(null, null, null, v2));
          }
          return results1;
        })() : impl.fromDsValue(null, null, null, value);
      }
      if (T.is_empty(infoFields)) {
        infoFields = null;
      }
      handle = (dsResponse != null ? dsResponse.handle : void 0) != null ? dsResponse.handle : cachedDatastore.get_handle();
      role = (ref = dsResponse != null ? dsResponse.role : void 0) != null ? ref : impl.ROLE_OWNER;
      return new Dropbox.Datastore.DatastoreInfo(dsid, handle, infoFields, role);
    };

    DatastoreManager.prototype._getOverlaidDatastoreInfosFromListResponse = function(resp) {
      var cachedIDs, dsInfo, dsResponse, dsid, id, l, len1, len2, map, o, ref;
      ListDatastoresResponse.Type(resp);
      cachedIDs = this._obj_manager.getAllCachedUndeletedDatastoreIDs();
      map = {};
      for (l = 0, len1 = cachedIDs.length; l < len1; l++) {
        dsid = cachedIDs[l];
        map[dsid] = null;
      }
      ref = resp.datastores;
      for (o = 0, len2 = ref.length; o < len2; o++) {
        dsResponse = ref[o];
        map[dsResponse.dsid] = dsResponse;
      }
      return (function() {
        var results1;
        results1 = [];
        for (id in map) {
          dsInfo = map[id];
          results1.push(this._getOverlaidDatastoreInfo(id, dsInfo));
        }
        return results1;
      }).call(this);
    };

    DatastoreManager.prototype._wrapDatastore = function(managed_datastore, created) {
      if (created) {
        managed_datastore._update_mtime();
        managed_datastore.sync();
      }
      return new Dropbox.Datastore(this, managed_datastore);
    };

    DatastoreManager.prototype._getOrCreateDatastoreByDsid = function(dsid, callback) {
      this._flob_client.get_or_create_db(dsid, (function(_this) {
        return function(err, resp) {
          if (err != null) {
            return callback(err);
          }
          if (resp.handle == null) {
            return callback(new Error("get_or_create_datastore failed for " + dsid));
          }
          return _this._obj_manager.open(dsid, resp.handle, function(err, managed_datastore) {
            if (err != null) {
              return callback(err);
            }
            return callback(null, _this._wrapDatastore(managed_datastore, resp.created));
          });
        };
      })(this));
      return void 0;
    };

    DatastoreManager.prototype._createDatastore = function(dsid, key, callback) {
      this._flob_client.create_db(dsid, key, (function(_this) {
        return function(err, resp) {
          if (err != null) {
            return callback(err);
          }
          if (resp.handle == null) {
            return callback(new Error("create_datastore failed for " + dsid));
          }
          return _this._obj_manager.open(dsid, resp.handle, function(err, managed_datastore) {
            if (err != null) {
              return callback(err);
            }
            return callback(null, _this._wrapDatastore(managed_datastore, resp.created));
          });
        };
      })(this));
      return void 0;
    };

    DatastoreManager.prototype._getExistingDatastoreByDsid = function(dsid, callback) {
      this._flob_client.get_db(dsid, (function(_this) {
        return function(err, resp) {
          if (err != null) {
            return callback(err);
          }
          if (resp.handle == null) {
            return callback(new Error("Datastore " + dsid + " not found or not accessible"));
          }
          return _this._obj_manager.open(dsid, resp.handle, function(err, managed_datastore) {
            if (err != null) {
              return callback(err);
            }
            return callback(null, new Dropbox.Datastore(_this, managed_datastore));
          });
        };
      })(this));
      return void 0;
    };

    DatastoreManager.prototype.openDefaultDatastore = function(callback) {
      this._getOrCreateDatastoreByDsid(DEFAULT_DATASTORE_ID, callback);
      return void 0;
    };

    DatastoreManager.prototype.openOrCreateDatastore = function(datastoreId, callback) {
      this._getOrCreateDatastoreByDsid(datastoreId, callback);
      return void 0;
    };

    DatastoreManager.prototype.openDatastore = function(datastoreId, callback) {
      this._getExistingDatastoreByDsid(datastoreId, callback);
      return void 0;
    };

    DatastoreManager.prototype.createDatastore = function(callback) {
      var dsid, key;
      key = impl.randomWeb64String(Math.ceil(256 / 6));
      dsid = "." + (impl.dbase64FromBase64(Dropbox.Util.sha256(key)));
      this._createDatastore(dsid, key, callback);
      return void 0;
    };

    DatastoreManager.prototype.deleteDatastore = function(dsid, callback) {
      this._flob_client.get_db(dsid, (function(_this) {
        return function(err, resp) {
          if (err != null) {
            return callback(err);
          }
          if (resp.handle == null) {
            return callback(new Error("Datastore " + dsid + " not found or not accessible"));
          }
          return _this._flob_client.delete_db(resp.handle, function(err) {
            if (err != null) {
              return callback(err);
            }
            return callback(null);
          });
        };
      })(this));
      return void 0;
    };

    DatastoreManager.prototype.listDatastores = function(callback) {
      if (this._lastListDsServerResponse != null) {
        return callback(null, this._getOverlaidDatastoreInfosFromListResponse(this._lastListDsServerResponse));
      }
      this._flob_client.list_dbs((function(_this) {
        return function(err, resp) {
          if (err != null) {
            return callback(err);
          }
          return callback(null, _this._getOverlaidDatastoreInfosFromListResponse(resp));
        };
      })(this));
      return void 0;
    };

    return DatastoreManager;

  })();

  Dropbox.Datastore.List = (function() {
    List.BASE_ITEM_SIZE = 20;

    function List(_datastore, _record, _field) {
      this._datastore = _datastore;
      this._record = _record;
      this._field = _field;
    }

    List.prototype.toString = function() {
      return "Datastore.List((" + this._record._tid + ", " + this._record._rid + ", " + this._field + "): " + (JSON.stringify(this._array)) + ")";
    };

    List.prototype._array = function() {
      return this._record._rawFieldValues()[this._field];
    };

    List.prototype._checkValid = function() {
      this._record._checkNotDeleted();
      if (!T.is_array(this._array())) {
        throw new Error("Attempt to operate on deleted list (" + this._record._tid + ", " + this._record._rid + ", " + this._field + ")");
      }
    };

    List.prototype._storeUpdate = function(fieldUpdate) {
      var recordUpdate;
      recordUpdate = {};
      recordUpdate[this._field] = fieldUpdate;
      this._record._storeUpdate(recordUpdate);
      return void 0;
    };

    List.prototype._fixInsertionIndex = function(x) {
      var len, y;
      if (!T.is_json_number(x)) {
        throw new RangeError("Index not a number: " + x);
      }
      len = this._array().length;
      y = x >= 0 ? x : len + x;
      if ((0 <= y && y <= len)) {
        return y;
      }
      throw new RangeError("Bad index for list of length " + len + ": " + x);
    };

    List.prototype._fixIndex = function(x) {
      var len, y;
      y = this._fixInsertionIndex(x);
      len = this._array().length;
      if (y < len) {
        return y;
      }
      throw new RangeError("Bad index for list of length " + len + ": " + x);
    };

    List.prototype.get = function(index) {
      var dsValue;
      this._checkValid();
      dsValue = impl.clone(this._array()[this._fixIndex(index)]);
      return impl.fromDsValue(void 0, void 0, void 0, dsValue);
    };

    List.prototype.set = function(index, value) {
      this._checkValid();
      index = this._fixIndex(index);
      this._storeUpdate(['LP', index, impl.toDsValue(value, false)]);
      return void 0;
    };

    List.prototype.length = function() {
      this._checkValid();
      return this._array().length;
    };

    List.prototype.pop = function() {
      this._checkValid();
      if (this._array().length === 0) {
        throw new Error("List is empty");
      }
      return this.remove(this._array.length - 1);
    };

    List.prototype.push = function(value) {
      this._checkValid();
      this.insert(this._array().length, value);
      return void 0;
    };

    List.prototype.shift = function() {
      this._checkValid();
      if (this._array().length === 0) {
        throw new Error("List is empty");
      }
      return this.remove(0);
    };

    List.prototype.unshift = function(value) {
      this.insert(0, value);
      return void 0;
    };

    List.prototype.splice = function() {
      var elements, howMany, i, index, l, len1, o, ref, result, x;
      index = arguments[0], howMany = arguments[1], elements = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this._checkValid();
      if ((!T.is_json_number(howMany)) || (howMany < 0)) {
        throw new RangeError("Bad second arg to splice: " + index + ", " + howMany);
      }
      index = this._fixInsertionIndex(index);
      result = this.slice(index, index + howMany);
      for (i = l = 0, ref = howMany; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        this.remove(index);
      }
      for (o = 0, len1 = elements.length; o < len1; o++) {
        x = elements[o];
        this.insert(index, x);
        index++;
      }
      return result;
    };

    List.prototype.move = function(oldIndex, newIndex) {
      this._checkValid();
      oldIndex = this._fixIndex(oldIndex);
      newIndex = this._fixIndex(newIndex);
      if (oldIndex === newIndex) {
        return void 0;
      }
      this._storeUpdate(['LM', oldIndex, newIndex]);
      return void 0;
    };

    List.prototype.remove = function(index) {
      var value;
      this._checkValid();
      index = this._fixIndex(index);
      value = this.get(index);
      this._storeUpdate(['LD', index]);
      return value;
    };

    List.prototype.insert = function(index, value) {
      this._checkValid();
      index = this._fixInsertionIndex(index);
      this._storeUpdate(['LI', index, impl.toDsValue(value, false)]);
      return void 0;
    };

    List.prototype.slice = function(from, to) {
      var x;
      this._checkValid();
      return (function() {
        var l, len1, ref, results1;
        ref = this._array().slice(from, to);
        results1 = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          x = ref[l];
          results1.push(impl.fromDsValue(void 0, void 0, void 0, x));
        }
        return results1;
      }).call(this);
    };

    List.prototype.toArray = function() {
      var x;
      this._checkValid();
      return (function() {
        var l, len1, ref, results1;
        ref = this._array().slice();
        results1 = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          x = ref[l];
          results1.push(impl.fromDsValue(void 0, void 0, void 0, x));
        }
        return results1;
      }).call(this);
    };

    return List;

  })();

  Dropbox.Datastore.Record = (function() {
    Record.RECORD_SIZE_LIMIT = 100 * 1024;

    Record.BASE_RECORD_SIZE = 100;

    Record.BASE_FIELD_SIZE = 100;

    Record.prototype.get = function(fieldName) {
      var fields;
      this._checkNotDeleted();
      fields = this._rawFieldValues();
      if (!(fieldName in fields)) {
        return null;
      }
      return impl.fromDsValue(this._datastore, this, fieldName, fields[fieldName]);
    };

    Record.prototype.set = function(fieldName, value) {
      var arg;
      arg = {};
      arg[fieldName] = value;
      return this.update(arg);
    };

    Record.prototype.getOrCreateList = function(fieldName) {
      var data, fields;
      this._checkNotDeleted();
      fields = this._rawFieldValues();
      if (fields[fieldName] == null) {
        data = {};
        data[fieldName] = ['LC'];
        this._storeUpdate(data);
        fields = this._rawFieldValues();
      } else if (!T.is_array(fields[fieldName])) {
        throw new Error("Can't call getOrCreateList on field " + fieldName + " for record (" + this.tid + ", " + this.rid + "): existing value " + fields[fieldName] + " is not a list");
      }
      return impl.fromDsValue(this._datastore, this, fieldName, fields[fieldName]);
    };

    Record.prototype.getFields = function() {
      var fieldValues, name, ref, value;
      this._checkNotDeleted();
      fieldValues = {};
      ref = this._rawFieldValues();
      for (name in ref) {
        value = ref[name];
        fieldValues[name] = impl.fromDsValue(this._datastore, this, name, value);
      }
      return fieldValues;
    };

    Record.prototype.getSize = function() {
      return this._managed_datastore.get_record_size(this._tid, this._rid);
    };

    Record.prototype.update = function(fieldValues) {
      var data, name, value;
      this._datastore._checkWritable();
      this._checkNotDeleted();
      data = {};
      for (name in fieldValues) {
        value = fieldValues[name];
        if (value != null) {
          data[name] = ['P', impl.toDsValue(value)];
        } else if ((this.get(name)) != null) {
          data[name] = ['D'];
        }
      }
      if (!T.is_empty(data)) {
        this._storeUpdate(data);
      }
      return this;
    };

    Record.prototype.deleteRecord = function() {
      var change;
      this._datastore._checkWritable();
      this._checkNotDeleted();
      this._deleted = true;
      this._record_cache.remove(this._tid, this._rid);
      change = Change.from_array(['D', this._tid, this._rid]);
      this._managed_datastore.perform_local_change(change);
      this._datastore._recordsChangedLocally([this]);
      return this;
    };

    Record.prototype.has = function(fieldName) {
      var fields;
      this._checkNotDeleted();
      fields = this._rawFieldValues();
      return fieldName in fields;
    };

    Record.prototype.getId = function() {
      return this._rid;
    };

    Record.prototype.getTable = function() {
      return this._datastore.getTable(this._tid);
    };

    Record.prototype.isDeleted = function() {
      return this._deleted;
    };

    Record.prototype.toString = function() {
      var fields;
      fields = this.isDeleted() ? 'deleted' : JSON.stringify(this.getFields());
      return "Datastore.Record((" + this._tid + ", " + this._rid + "): " + fields + ")";
    };

    Record.prototype._rawFieldValues = function() {
      return this._managed_datastore.query(this._tid, this._rid);
    };

    Record.prototype._storeUpdate = function(recordUpdate) {
      var change;
      change = Change.from_array(['U', this._tid, this._rid, recordUpdate]);
      this._managed_datastore.perform_local_change(change);
      this._datastore._recordsChangedLocally([this]);
    };

    Record.isValidId = function(recordId) {
      var recordIdRe;
      recordIdRe = new RegExp(T.SS_ID_REGEX);
      return T.is_string(recordId) && recordIdRe.test(recordId);
    };

    function Record(_datastore, _tid, _rid) {
      this._datastore = _datastore;
      this._tid = _tid;
      this._rid = _rid;
      this._deleted = false;
      this._record_cache = this._datastore._record_cache;
      this._managed_datastore = this._datastore._managed_datastore;
    }

    Record.prototype._checkNotDeleted = function() {
      if (this._deleted) {
        throw new Error("Attempt to operate on deleted record (" + this._tid + ", " + this._rid + ")");
      }
    };

    return Record;

  })();

  Dropbox.Datastore.RecordsChanged = (function() {
    function RecordsChanged(_recordsByTable, _local) {
      this._recordsByTable = _recordsByTable;
      this._local = _local;
    }

    RecordsChanged.prototype.toString = function() {
      var list, r, recordCount, ref, t, tableCount, tableid;
      tableCount = 0;
      recordCount = 0;
      ref = this._recordsByTable;
      for (tableid in ref) {
        list = ref[tableid];
        tableCount += 1;
        recordCount += list.length;
      }
      t = tableCount + " " + (tableCount === 1 ? 'table' : 'tables');
      r = recordCount + " " + (recordCount === 1 ? 'record' : 'records');
      return "Datastore.RecordsChanged(" + r + " in " + t + " changed " + (this._local ? 'locally' : 'remotely') + ")";
    };

    RecordsChanged._fromRecordList = function(records, local) {
      var l, len1, record, recordsByTable, tid;
      recordsByTable = {};
      for (l = 0, len1 = records.length; l < len1; l++) {
        record = records[l];
        tid = record._tid;
        if (recordsByTable[tid] == null) {
          recordsByTable[tid] = [];
        }
        recordsByTable[tid].push(record);
      }
      return new RecordsChanged(recordsByTable, local);
    };

    RecordsChanged.prototype.affectedRecordsByTable = function() {
      return this._recordsByTable;
    };

    RecordsChanged.prototype.affectedRecordsForTable = function(tableId) {
      var ref;
      return (ref = this._recordsByTable[tableId]) != null ? ref : [];
    };

    RecordsChanged.prototype.isLocal = function() {
      return this._local;
    };

    return RecordsChanged;

  })();

  RecordsChanged = Dropbox.Datastore.RecordsChanged;

  Dropbox.Datastore.Table = (function() {
    Table.prototype.getId = function() {
      return this._tid;
    };

    Table.prototype.get = function(recordId) {
      var contents, record;
      if (!Dropbox.Datastore.Record.isValidId(recordId)) {
        throw new Error("Invalid record ID: " + recordId);
      }
      record = this._record_cache.get(this._tid, recordId);
      if (record != null) {
        assert(!record._deleted);
        return record;
      }
      contents = this._managed_datastore.query(this._tid, recordId);
      if (contents == null) {
        return null;
      }
      return this._record_cache.getOrCreate(this._tid, recordId);
    };

    Table.prototype.getOrInsert = function(recordId, defaultValues) {
      var existing;
      this._datastore._checkWritable();
      existing = this.get(recordId);
      if (existing) {
        return existing;
      }
      return this._insertWithId(recordId, defaultValues);
    };

    Table.prototype.insert = function(fieldValues) {
      var recordId;
      this._datastore._checkWritable();
      recordId = this._datastore._generateRid();
      assert((this.get(recordId)) == null);
      return this._insertWithId(recordId, fieldValues);
    };

    Table.prototype.query = function(fieldValues) {
      var data, l, len1, record, ret, rid, rids;
      rids = this._managed_datastore.list_rows_for_table(this._tid);
      ret = [];
      for (l = 0, len1 = rids.length; l < len1; l++) {
        rid = rids[l];
        data = this._managed_datastore.query(this._tid, rid);
        if ((fieldValues == null) || impl.matchDsValues(fieldValues, data)) {
          record = this.get(rid);
          assert(record != null);
          ret.push(record);
        }
      }
      return ret;
    };

    Table.prototype.setResolutionRule = function(fieldName, rule) {
      if (rule !== 'remote' && rule !== 'local' && rule !== 'min' && rule !== 'max' && rule !== 'sum') {
        throw new Error(rule + " is not a valid resolution rule. Valid rules are 'remote', 'local', 'min', 'max', and 'sum'.");
      }
      this._managed_datastore.resolver.add_resolution_rule(this._tid, fieldName, rule);
      return this;
    };

    Table.isValidId = function(tableId) {
      var tableIdRe;
      tableIdRe = new RegExp(T.SS_ID_REGEX);
      return T.is_string(tableId) && tableIdRe.test(tableId);
    };

    function Table(_datastore, _tid) {
      this._datastore = _datastore;
      this._tid = _tid;
      this._record_cache = this._datastore._record_cache;
      this._managed_datastore = this._datastore._managed_datastore;
    }

    Table.prototype.toString = function() {
      return "Datastore.Table(" + this._tid + ")";
    };

    Table.prototype._insertWithId = function(rid, fieldVals) {
      var change, data, k, record, v;
      data = {};
      for (k in fieldVals) {
        v = fieldVals[k];
        data[k] = impl.toDsValue(v);
      }
      change = Change.from_array(['I', this._tid, rid, data]);
      this._managed_datastore.perform_local_change(change);
      record = this._record_cache.getOrCreate(this._tid, rid);
      this._datastore._recordsChangedLocally([record]);
      return record;
    };

    return Table;

  })();

  Dropbox.File.ShareUrl = (function() {
    ShareUrl.parse = function(urlData, isDirect) {
      if (urlData && typeof urlData === 'object') {
        return new Dropbox.File.ShareUrl(urlData, isDirect);
      } else {
        return urlData;
      }
    };

    ShareUrl.prototype.url = null;

    ShareUrl.prototype.expiresAt = null;

    ShareUrl.prototype.isDirect = null;

    ShareUrl.prototype.isPreview = null;

    ShareUrl.prototype.json = function() {
      return this._json || (this._json = {
        url: this.url,
        expires: this.expiresAt.toUTCString(),
        direct: this.isDirect
      });
    };

    function ShareUrl(urlData, isDirect) {
      this.url = urlData.url;
      this.expiresAt = Dropbox.Util.parseDate(urlData.expires);
      if (isDirect === true) {
        this.isDirect = true;
      } else if (isDirect === false) {
        this.isDirect = false;
      } else {
        if ('direct' in urlData) {
          this.isDirect = urlData.direct;
        } else {
          this.isDirect = Date.now() - this.expiresAt <= 86400000;
        }
      }
      this.isPreview = !this.isDirect;
      this._json = null;
    }

    return ShareUrl;

  })();

  Dropbox.File.CopyReference = (function() {
    CopyReference.parse = function(refData) {
      if (refData && (typeof refData === 'object' || typeof refData === 'string')) {
        return new Dropbox.File.CopyReference(refData);
      } else {
        return refData;
      }
    };

    CopyReference.prototype.tag = null;

    CopyReference.prototype.expiresAt = null;

    CopyReference.prototype.json = function() {
      return this._json || (this._json = {
        copy_ref: this.tag,
        expires: this.expiresAt.toUTCString()
      });
    };

    function CopyReference(refData) {
      if (typeof refData === 'object') {
        this.tag = refData.copy_ref;
        this.expiresAt = Dropbox.Util.parseDate(refData.expires);
        this._json = refData;
      } else {
        this.tag = refData;
        this.expiresAt = new Date(Math.ceil(Date.now() / 1000) * 1000);
        this._json = null;
      }
    }

    return CopyReference;

  })();

  Dropbox.File.Stat = (function() {
    Stat.parse = function(metadata) {
      if (metadata && typeof metadata === 'object') {
        return new Dropbox.File.Stat(metadata);
      } else {
        return metadata;
      }
    };

    Stat.prototype.path = null;

    Stat.prototype.name = null;

    Stat.prototype.inAppFolder = null;

    Stat.prototype.isFolder = null;

    Stat.prototype.isFile = null;

    Stat.prototype.isRemoved = null;

    Stat.prototype.typeIcon = null;

    Stat.prototype.versionTag = null;

    Stat.prototype.contentHash = null;

    Stat.prototype.mimeType = null;

    Stat.prototype.size = null;

    Stat.prototype.humanSize = null;

    Stat.prototype.hasThumbnail = null;

    Stat.prototype.modifiedAt = null;

    Stat.prototype.clientModifiedAt = null;

    Stat.prototype.json = function() {
      return this._json;
    };

    function Stat(metadata) {
      var lastIndex, nameSlash, ref, ref1;
      this._json = metadata;
      this.path = metadata.path;
      if (this.path.substring(0, 1) !== '/') {
        this.path = '/' + this.path;
      }
      lastIndex = this.path.length - 1;
      if (lastIndex >= 0 && this.path.substring(lastIndex) === '/') {
        this.path = this.path.substring(0, lastIndex);
      }
      nameSlash = this.path.lastIndexOf('/');
      this.name = this.path.substring(nameSlash + 1);
      this.isFolder = metadata.is_dir || false;
      this.isFile = !this.isFolder;
      this.isRemoved = metadata.is_deleted || false;
      this.typeIcon = metadata.icon;
      if ((ref = metadata.modified) != null ? ref.length : void 0) {
        this.modifiedAt = Dropbox.Util.parseDate(metadata.modified);
      } else {
        this.modifiedAt = null;
      }
      if ((ref1 = metadata.client_mtime) != null ? ref1.length : void 0) {
        this.clientModifiedAt = Dropbox.Util.parseDate(metadata.client_mtime);
      } else {
        this.clientModifiedAt = null;
      }
      switch (metadata.root) {
        case 'dropbox':
          this.inAppFolder = false;
          break;
        case 'app_folder':
          this.inAppFolder = true;
          break;
        default:
          this.inAppFolder = null;
      }
      this.size = metadata.bytes || 0;
      this.humanSize = metadata.size || '';
      this.hasThumbnail = metadata.thumb_exists || false;
      this.versionTag = metadata.rev;
      this.contentHash = metadata.hash || null;
      if (this.isFolder) {
        this.mimeType = metadata.mime_type || 'inode/directory';
      } else {
        this.mimeType = metadata.mime_type || 'application/octet-stream';
      }
    }

    return Stat;

  })();

  Dropbox.Http.AppInfo = (function() {
    AppInfo.parse = function(appInfo, appKey) {
      if (appInfo) {
        return new Dropbox.Http.AppInfo(appInfo, appKey);
      } else {
        return appInfo;
      }
    };

    AppInfo.prototype.name = void 0;

    AppInfo.prototype.key = void 0;

    AppInfo.prototype.canUseDatastores = void 0;

    AppInfo.prototype.canUseFiles = void 0;

    AppInfo.prototype.hasAppFolder = void 0;

    AppInfo.prototype.canUseFullDropbox = void 0;

    AppInfo.prototype.icon = function(width, height) {
      height || (height = width);
      return this._icons[width + "x" + height] || null;
    };

    AppInfo.ICON_SMALL = 64;

    AppInfo.ICON_LARGE = 256;

    function AppInfo(appInfo, appKey) {
      var permissions;
      this.name = appInfo.name;
      this._icons = appInfo.icons;
      permissions = appInfo.permissions || {};
      this.canUseDatastores = !!permissions.datastores;
      this.canUseFiles = !!permissions.files;
      this.canUseFullDropbox = permissions.files === 'full_dropbox';
      this.hasAppFolder = permissions.files === 'app_folder';
      if (appKey) {
        this.key = appKey;
      } else {
        this.key = appInfo.key || null;
      }
    }

    return AppInfo;

  })();

  Dropbox.Http.PulledChanges = (function() {
    PulledChanges.parse = function(deltaInfo) {
      if (deltaInfo && typeof deltaInfo === 'object') {
        return new Dropbox.Http.PulledChanges(deltaInfo);
      } else {
        return deltaInfo;
      }
    };

    PulledChanges.prototype.blankSlate = void 0;

    PulledChanges.prototype.cursorTag = void 0;

    PulledChanges.prototype.changes = void 0;

    PulledChanges.prototype.shouldPullAgain = void 0;

    PulledChanges.prototype.shouldBackOff = void 0;

    PulledChanges.prototype.cursor = function() {
      return this.cursorTag;
    };

    function PulledChanges(deltaInfo) {
      var entry;
      this.blankSlate = deltaInfo.reset || false;
      this.cursorTag = deltaInfo.cursor;
      this.shouldPullAgain = deltaInfo.has_more;
      this.shouldBackOff = !this.shouldPullAgain;
      if (deltaInfo.cursor && deltaInfo.cursor.length) {
        this.changes = (function() {
          var l, len1, ref, results1;
          ref = deltaInfo.entries;
          results1 = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            entry = ref[l];
            results1.push(Dropbox.Http.PulledChange.parse(entry));
          }
          return results1;
        })();
      } else {
        this.changes = [];
      }
    }

    return PulledChanges;

  })();

  Dropbox.Http.PulledChange = (function() {
    PulledChange.parse = function(entry) {
      if (entry && typeof entry === 'object') {
        return new Dropbox.Http.PulledChange(entry);
      } else {
        return entry;
      }
    };

    PulledChange.prototype.path = void 0;

    PulledChange.prototype.wasRemoved = void 0;

    PulledChange.prototype.stat = void 0;

    function PulledChange(entry) {
      this.path = entry[0];
      this.stat = Dropbox.File.Stat.parse(entry[1]);
      if (this.stat) {
        this.wasRemoved = false;
      } else {
        this.stat = null;
        this.wasRemoved = true;
      }
    }

    return PulledChange;

  })();

  Dropbox.Http.PollResult = (function() {
    PollResult.parse = function(response) {
      if (response) {
        return new Dropbox.Http.PollResult(response);
      } else {
        return response;
      }
    };

    PollResult.prototype.hasChanges = void 0;

    PollResult.prototype.retryAfter = void 0;

    function PollResult(response) {
      this.hasChanges = response.changes;
      this.retryAfter = response.backoff || 0;
    }

    return PollResult;

  })();

  Dropbox.Http.RangeInfo = (function() {
    RangeInfo.parse = function(headerValue) {
      if (typeof headerValue === 'string') {
        return new Dropbox.Http.RangeInfo(headerValue);
      } else {
        return headerValue;
      }
    };

    RangeInfo.prototype.start = null;

    RangeInfo.prototype.size = null;

    RangeInfo.prototype.end = null;

    function RangeInfo(headerValue) {
      var match;
      if (match = /^bytes (\d*)-(\d*)\/(.*)$/.exec(headerValue)) {
        this.start = parseInt(match[1]);
        this.end = parseInt(match[2]);
        if (match[3] === '*') {
          this.size = null;
        } else {
          this.size = parseInt(match[3]);
        }
      } else {
        this.start = 0;
        this.end = 0;
        this.size = null;
      }
    }

    return RangeInfo;

  })();

  Dropbox.Http.UploadCursor = (function() {
    UploadCursor.parse = function(cursorData) {
      if (cursorData && (typeof cursorData === 'object' || typeof cursorData === 'string')) {
        return new Dropbox.Http.UploadCursor(cursorData);
      } else {
        return cursorData;
      }
    };

    UploadCursor.prototype.tag = null;

    UploadCursor.prototype.offset = null;

    UploadCursor.prototype.expiresAt = null;

    UploadCursor.prototype.json = function() {
      return this._json || (this._json = {
        upload_id: this.tag,
        offset: this.offset,
        expires: this.expiresAt.toUTCString()
      });
    };

    function UploadCursor(cursorData) {
      this.replace(cursorData);
    }

    UploadCursor.prototype.replace = function(cursorData) {
      if (typeof cursorData === 'object') {
        this.tag = cursorData.upload_id || null;
        this.offset = cursorData.offset || 0;
        this.expiresAt = Dropbox.Util.parseDate(cursorData.expires) || Date.now();
        this._json = cursorData;
      } else {
        this.tag = cursorData || null;
        this.offset = 0;
        this.expiresAt = new Date(Math.floor(Date.now() / 1000) * 1000);
        this._json = null;
      }
      return this;
    };

    return UploadCursor;

  })();

  if (typeof Dropbox.Env.global.atob === 'function' && typeof Dropbox.Env.global.btoa === 'function') {
    Dropbox.Util.atob = function(string) {
      return Dropbox.Env.global.atob(string);
    };
    Dropbox.Util.btoa = function(base64) {
      return Dropbox.Env.global.btoa(base64);
    };
  } else if (Dropbox.Env.global.require && Dropbox.Env.global.Buffer) {
    Dropbox.Util.atob = function(arg) {
      var buffer, i;
      buffer = new Buffer(arg, 'base64');
      return ((function() {
        var l, ref, results1;
        results1 = [];
        for (i = l = 0, ref = buffer.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          results1.push(String.fromCharCode(buffer[i]));
        }
        return results1;
      })()).join('');
    };
    Dropbox.Util.btoa = function(arg) {
      var buffer, i;
      buffer = new Buffer((function() {
        var l, ref, results1;
        results1 = [];
        for (i = l = 0, ref = arg.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          results1.push(arg.charCodeAt(i));
        }
        return results1;
      })());
      return buffer.toString('base64');
    };
  } else {
    (function() {
      var atobNibble, base64Digits, btoaNibble;
      base64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      btoaNibble = function(accumulator, bytes, result) {
        var i, limit;
        limit = 3 - bytes;
        accumulator <<= limit * 8;
        i = 3;
        while (i >= limit) {
          result.push(base64Digits.charAt((accumulator >> (i * 6)) & 0x3F));
          i -= 1;
        }
        i = bytes;
        while (i < 3) {
          result.push('=');
          i += 1;
        }
        return null;
      };
      atobNibble = function(accumulator, digits, result) {
        var i, limit;
        limit = 4 - digits;
        accumulator <<= limit * 6;
        i = 2;
        while (i >= limit) {
          result.push(String.fromCharCode((accumulator >> (8 * i)) & 0xFF));
          i -= 1;
        }
        return null;
      };
      Dropbox.Util.btoa = function(string) {
        var accumulator, bytes, i, l, ref, result;
        result = [];
        accumulator = 0;
        bytes = 0;
        for (i = l = 0, ref = string.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          accumulator = (accumulator << 8) | string.charCodeAt(i);
          bytes += 1;
          if (bytes === 3) {
            btoaNibble(accumulator, bytes, result);
            accumulator = bytes = 0;
          }
        }
        if (bytes > 0) {
          btoaNibble(accumulator, bytes, result);
        }
        return result.join('');
      };
      return Dropbox.Util.atob = function(base64) {
        var accumulator, digit, digits, i, l, ref, result;
        result = [];
        accumulator = 0;
        digits = 0;
        for (i = l = 0, ref = base64.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          digit = base64.charAt(i);
          if (digit === '=') {
            break;
          }
          accumulator = (accumulator << 6) | base64Digits.indexOf(digit);
          digits += 1;
          if (digits === 4) {
            atobNibble(accumulator, digits, result);
            accumulator = digits = 0;
          }
        }
        if (digits > 0) {
          atobNibble(accumulator, digits, result);
        }
        return result.join('');
      };
    })();
  }

  (function() {
    var _base64Digits, arrayToBase64, crypto, hmacSha1, requireError, sha1, sha256, sha256Init, sha256Key, stringToArray, xxx;
    Dropbox.Util.hmac = function(string, key) {
      return arrayToBase64(hmacSha1(stringToArray(string), stringToArray(key), string.length, key.length));
    };
    Dropbox.Util.sha1 = function(string) {
      return arrayToBase64(sha1(stringToArray(string), string.length));
    };
    Dropbox.Util.sha256 = function(string) {
      return arrayToBase64(sha256(stringToArray(string), string.length));
    };
    if (Dropbox.Env.require) {
      try {
        crypto = Dropbox.Env.require('crypto');
        if (crypto.createHmac && crypto.createHash) {
          Dropbox.Util.hmac = function(string, key) {
            var hmac;
            hmac = crypto.createHmac('sha1', key);
            hmac.update(string);
            return hmac.digest('base64');
          };
          Dropbox.Util.sha1 = function(string) {
            var hash;
            hash = crypto.createHash('sha1');
            hash.update(string);
            return hash.digest('base64');
          };
          Dropbox.Util.sha256 = function(string) {
            var hash;
            hash = crypto.createHash('sha256');
            hash.update(string);
            return hash.digest('base64');
          };
        }
      } catch (_error) {
        requireError = _error;
      }
    }
    hmacSha1 = function(string, key, length, keyLength) {
      var hash1, i, ipad, opad;
      if (key.length > 16) {
        key = sha1(key, keyLength);
      }
      ipad = (function() {
        var l, results1;
        results1 = [];
        for (i = l = 0; l < 16; i = ++l) {
          results1.push(key[i] ^ 0x36363636);
        }
        return results1;
      })();
      opad = (function() {
        var l, results1;
        results1 = [];
        for (i = l = 0; l < 16; i = ++l) {
          results1.push(key[i] ^ 0x5C5C5C5C);
        }
        return results1;
      })();
      hash1 = sha1(ipad.concat(string), 64 + length);
      return sha1(opad.concat(hash1), 64 + 20);
    };
    sha1 = function(string, length) {
      var a, a0, b, b0, c, c0, d, d0, e, e0, i, j, l, limit, n, state, t;
      string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
      string[(((length + 8) >> 6) << 4) + 15] = length << 3;
      state = Array(80);
      a = 0x67452301;
      b = 0xefcdab89;
      c = 0x98badcfe;
      d = 0x10325476;
      e = 0xc3d2e1f0;
      i = 0;
      limit = string.length;
      while (i < limit) {
        a0 = a;
        b0 = b;
        c0 = c;
        d0 = d;
        e0 = e;
        for (j = l = 0; l < 80; j = ++l) {
          if (j < 16) {
            state[j] = string[(i + j) << 2 >> 2] | 0;
          } else {
            n = (state[(j - 3) << 2 >> 2] | 0) ^ (state[(j - 8) << 2 >> 2] | 0) ^ (state[(j - 14) << 2 >> 2] | 0) ^ (state[(j - 16) << 2 >> 2] | 0);
            state[j] = (n << 1) | (n >>> 31);
          }
          t = (((((a << 5) | (a >>> 27)) + e) | 0) + state[j << 2 >> 2]) | 0;
          if (j < 20) {
            t = (t + ((((b & c) | (~b & d)) + 0x5a827999) | 0)) | 0;
          } else if (j < 40) {
            t = (t + (((b ^ c ^ d) + 0x6ed9eba1) | 0)) | 0;
          } else if (j < 60) {
            t = (t + (((b & c) | (b & d) | (c & d)) - 0x70e44324) | 0) | 0;
          } else {
            t = (t + (((b ^ c ^ d) - 0x359d3e2a) | 0)) | 0;
          }
          e = d;
          d = c;
          c = (b << 30) | (b >>> 2);
          b = a;
          a = t;
        }
        a = (a0 + a) | 0;
        b = (b0 + b) | 0;
        c = (c0 + c) | 0;
        d = (d0 + d) | 0;
        e = (e0 + e) | 0;
        i = (i + 16) | 0;
      }
      return [a, b, c, d, e];
    };
    sha256 = function(string, length) {
      var a, a0, b, b0, c, c0, ch, d, d0, e, e0, f, f0, g, g0, gamma0, gamma0x, gamma1, gamma1x, h, h0, i, j, l, limit, maj, sigma0, sigma1, sj, state, t1, t2;
      string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
      string[(((length + 8) >> 6) << 4) + 15] = length << 3;
      state = Array(80);
      a = sha256Init[0], b = sha256Init[1], c = sha256Init[2], d = sha256Init[3], e = sha256Init[4], f = sha256Init[5], g = sha256Init[6], h = sha256Init[7];
      i = 0;
      limit = string.length;
      while (i < limit) {
        a0 = a;
        b0 = b;
        c0 = c;
        d0 = d;
        e0 = e;
        f0 = f;
        g0 = g;
        h0 = h;
        for (j = l = 0; l < 64; j = ++l) {
          if (j < 16) {
            sj = state[j] = string[(i + j) << 2 >> 2] | 0;
          } else {
            gamma0x = state[(j - 15) << 2 >> 2] | 0;
            gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);
            gamma1x = state[(j - 2) << 2 >> 2] | 0;
            gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);
            sj = state[j] = (((gamma0 + (state[(j - 7) << 2 >> 2] | 0)) | 0) + ((gamma1 + (state[(j - 16) << 2 >> 2] | 0)) | 0)) | 0;
          }
          ch = (e & f) ^ (~e & g);
          maj = (a & b) ^ (a & c) ^ (b & c);
          sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
          sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
          t1 = (((((h + sigma1) | 0) + ((ch + sj) | 0)) | 0) + (sha256Key[j << 2 >> 2] | 0)) | 0;
          t2 = (sigma0 + maj) | 0;
          h = g;
          g = f;
          f = e;
          e = (d + t1) | 0;
          d = c;
          c = b;
          b = a;
          a = (t1 + t2) | 0;
        }
        a = (a0 + a) | 0;
        b = (b0 + b) | 0;
        c = (c0 + c) | 0;
        d = (d0 + d) | 0;
        e = (e0 + e) | 0;
        f = (f0 + f) | 0;
        g = (g0 + g) | 0;
        h = (h0 + h) | 0;
        i += 16;
      }
      return [a, b, c, d, e, f, g, h];
    };
    xxx = function(n) {
      if (n < 0) {
        n = (1 << 30) * 4 + n;
      }
      return n.toString(16);
    };
    sha256Init = [];
    sha256Key = [];
    (function() {
      var factor, fractional, i, isPrime, l, prime, results1;
      fractional = function(x) {
        return ((x - Math.floor(x)) * 0x100000000) | 0;
      };
      prime = 2;
      results1 = [];
      for (i = l = 0; l < 64; i = ++l) {
        while (true) {
          isPrime = true;
          factor = 2;
          while (factor * factor <= prime) {
            if (prime % factor === 0) {
              isPrime = false;
              break;
            }
            factor += 1;
          }
          if (isPrime) {
            break;
          }
          prime += 1;
          continue;
        }
        if (i < 8) {
          sha256Init[i] = fractional(Math.pow(prime, 1 / 2));
        }
        sha256Key[i] = fractional(Math.pow(prime, 1 / 3));
        results1.push(prime += 1);
      }
      return results1;
    })();
    arrayToBase64 = function(array) {
      var i, i2, limit, string, trit;
      string = "";
      i = 0;
      limit = array.length * 4;
      while (i < limit) {
        i2 = i;
        trit = ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 16;
        i2 += 1;
        trit |= ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 8;
        i2 += 1;
        trit |= (array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF;
        string += _base64Digits[(trit >> 18) & 0x3F];
        string += _base64Digits[(trit >> 12) & 0x3F];
        i += 1;
        if (i >= limit) {
          string += '=';
        } else {
          string += _base64Digits[(trit >> 6) & 0x3F];
        }
        i += 1;
        if (i >= limit) {
          string += '=';
        } else {
          string += _base64Digits[trit & 0x3F];
        }
        i += 1;
      }
      return string;
    };
    _base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    return stringToArray = function(string) {
      var array, i, l, mask, ref;
      array = [];
      mask = 0xFF;
      for (i = l = 0, ref = string.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        array[i >> 2] |= (string.charCodeAt(i) & mask) << ((3 - (i & 3)) << 3);
      }
      return array;
    };
  })();

  Dropbox.Util.Oauth = (function() {
    function Oauth(options) {
      this._id = null;
      this._secret = null;
      this._stateParam = null;
      this._authCode = null;
      this._token = null;
      this._tokenKey = null;
      this._tokenKid = null;
      this._error = null;
      this._appHash = null;
      this._loaded = null;
      this.setCredentials(options);
    }

    Oauth.prototype.setCredentials = function(options) {
      if (options.key) {
        this._id = options.key;
      } else {
        if (!options.token) {
          throw new Error('No API key supplied');
        }
        this._id = null;
      }
      this._secret = options.secret || null;
      this._appHash = null;
      this._error = null;
      this._loaded = true;
      this.reset();
      if (options.token) {
        this._token = options.token;
        if (options.tokenKey) {
          this._tokenKey = options.tokenKey;
          this._tokenKid = options.tokenKid;
        }
      } else if (options.oauthCode) {
        this._authCode = options.oauthCode;
      } else if (options.oauthStateParam) {
        this._stateParam = options.oauthStateParam;
      }
      return this;
    };

    Oauth.prototype.credentials = function() {
      var returnValue;
      returnValue = {};
      if (this._id) {
        returnValue.key = this._id;
      }
      if (this._secret) {
        returnValue.secret = this._secret;
      }
      if (this._token !== null) {
        returnValue.token = this._token;
        if (this._tokenKey) {
          returnValue.tokenKey = this._tokenKey;
          returnValue.tokenKid = this._tokenKid;
        }
      } else if (this._authCode !== null) {
        returnValue.oauthCode = this._authCode;
      } else if (this._stateParam !== null) {
        returnValue.oauthStateParam = this._stateParam;
      }
      return returnValue;
    };

    Oauth.prototype.step = function() {
      if (this._token !== null) {
        return Dropbox.Client.DONE;
      } else if (this._authCode !== null) {
        return Dropbox.Client.AUTHORIZED;
      } else if (this._stateParam !== null) {
        if (this._loaded) {
          return Dropbox.Client.PARAM_LOADED;
        } else {
          return Dropbox.Client.PARAM_SET;
        }
      } else if (this._error !== null) {
        return Dropbox.Client.ERROR;
      } else {
        return Dropbox.Client.RESET;
      }
    };

    Oauth.prototype.setAuthStateParam = function(stateParam) {
      if (this._id === null) {
        throw new Error('No API key supplied, cannot do authorization');
      }
      this.reset();
      this._loaded = false;
      this._stateParam = stateParam;
      return this;
    };

    Oauth.prototype.checkAuthStateParam = function(stateParam) {
      return (this._stateParam === stateParam) && (this._stateParam !== null);
    };

    Oauth.prototype.authStateParam = function() {
      return this._stateParam;
    };

    Oauth.prototype.error = function() {
      return this._error;
    };

    Oauth.prototype.processRedirectParams = function(queryParams) {
      var tokenType;
      if (queryParams.error) {
        if (this._id === null) {
          throw new Error('No API key supplied, cannot process errors');
        }
        this.reset();
        this._error = new Dropbox.AuthError(queryParams);
        return true;
      }
      if (queryParams.code) {
        if (this._id === null) {
          throw new Error('No API key supplied, cannot do Authorization Codes');
        }
        this.reset();
        this._loaded = false;
        this._authCode = queryParams.code;
        return true;
      }
      tokenType = queryParams.token_type;
      if (tokenType) {
        tokenType = tokenType.toLowerCase();
        if (tokenType !== 'bearer' && tokenType !== 'mac') {
          throw new Error("Unimplemented token type " + tokenType);
        }
        this.reset();
        this._loaded = false;
        if (tokenType === 'mac') {
          if (queryParams.mac_algorithm !== 'hmac-sha-1') {
            throw new Error("Unimplemented MAC algorithms " + queryParams.mac_algorithm);
          }
          this._tokenKey = queryParams.mac_key;
          this._tokenKid = queryParams.kid;
        }
        this._token = queryParams.access_token;
        return true;
      }
      return false;
    };

    Oauth.prototype.authHeader = function(method, url, params) {
      var macParams, userPassword;
      if (this._token === null) {
        userPassword = this._secret === null ? Dropbox.Util.btoa(this._id + ":") : Dropbox.Util.btoa(this._id + ":" + this._secret);
        return "Basic " + userPassword;
      } else {
        if (this._tokenKey === null) {
          return "Bearer " + this._token;
        } else {
          macParams = this.macParams(method, url, params);
          return ("MAC kid=" + macParams.kid + " ts=" + macParams.ts + " ") + ("access_token=" + this._token + " mac=" + macParams.mac);
        }
      }
    };

    Oauth.prototype.addAuthParams = function(method, url, params) {
      var macParams;
      if (this._token === null) {
        params.client_id = this._id;
        if (this._secret !== null) {
          params.client_secret = this._secret;
        }
      } else {
        if (this._tokenKey !== null) {
          macParams = this.macParams(method, url, params);
          params.kid = macParams.kid;
          params.ts = macParams.ts;
          params.mac = macParams.mac;
        }
        params.access_token = this._token;
      }
      return params;
    };

    Oauth.prototype.authorizeUrlParams = function(responseType, redirectUrl) {
      var params;
      if (responseType !== 'token' && responseType !== 'code') {
        throw new Error("Unimplemented /authorize response type " + responseType);
      }
      params = {
        client_id: this._id,
        state: this._stateParam,
        response_type: responseType
      };
      if (redirectUrl) {
        params.redirect_uri = redirectUrl;
      }
      return params;
    };

    Oauth.prototype.accessTokenParams = function(redirectUrl) {
      var params;
      params = {
        grant_type: 'authorization_code',
        code: this._authCode
      };
      if (redirectUrl) {
        params.redirect_uri = redirectUrl;
      }
      return params;
    };

    Oauth.queryParamsFromUrl = function(url) {
      var fragment, fragmentOffset, kvp, l, len1, match, offset, params, query, ref;
      match = /^[^?#]+(\?([^\#]*))?(\#(.*))?$/.exec(url);
      if (!match) {
        return {};
      }
      query = match[2] || '';
      if (query.substring(0, 1) === '/') {
        query = query.substring(1);
      }
      fragment = match[4] || '';
      fragmentOffset = fragment.indexOf('?');
      if (fragmentOffset !== -1) {
        fragment = fragment.substring(fragmentOffset + 1);
      }
      if (fragment.substring(0, 1) === '/') {
        fragment = fragment.substring(1);
      }
      params = {};
      ref = query.split('&').concat(fragment.split('&'));
      for (l = 0, len1 = ref.length; l < len1; l++) {
        kvp = ref[l];
        offset = kvp.indexOf('=');
        if (offset === -1) {
          continue;
        }
        params[decodeURIComponent(kvp.substring(0, offset))] = decodeURIComponent(kvp.substring(offset + 1));
      }
      return params;
    };

    Oauth.prototype.macParams = function(method, url, params) {
      var macParams, string;
      macParams = {
        kid: this._tokenKid,
        ts: Dropbox.Util.Oauth.timestamp()
      };
      string = method.toUpperCase() + '&' + Dropbox.Util.Xhr.urlEncodeValue(url) + '&' + Dropbox.Util.Xhr.urlEncodeValue(Dropbox.Util.Xhr.urlEncode(params));
      macParams.mac = Dropbox.Util.hmac(string, this._tokenKey);
      return macParams;
    };

    Oauth.prototype.appHash = function() {
      if (this._appHash) {
        return this._appHash;
      }
      return this._appHash = Dropbox.Util.sha1('oauth2-' + this._id).replace(/[\/+=]/g, '');
    };

    Oauth.prototype.reset = function() {
      this._stateParam = null;
      this._authCode = null;
      this._token = null;
      this._tokenKey = null;
      this._tokenKid = null;
      this._error = null;
      return this;
    };

    Oauth.timestamp = function() {
      return Math.floor(Date.now() / 1000);
    };

    Oauth.randomAuthStateParam = function() {
      return ['oas', Date.now().toString(36), Math.random().toString(36)].join('_');
    };

    return Oauth;

  })();

  if (Date.now == null) {
    Dropbox.Util.Oauth.timestamp = function() {
      return Math.floor((new Date()).getTime() / 1000);
    };
  }

  if ((new Date('Fri, 31 Jan 2042 21:01:05 +0000')).valueOf() === 2274814865000) {
    Dropbox.Util.parseDate = function(dateString) {
      return new Date(dateString);
    };
  } else if (Date.parse('Fri, 31 Jan 2042 21:01:05 +0000') === 2274814865000) {
    Dropbox.Util.parseDate = function(dateString) {
      return new Date(Date.parse(dateString));
    };
  } else {
    (function() {
      var parseDateMonths, parseDateRe;
      parseDateRe = /^\w+\, (\d+) (\w+) (\d+) (\d+)\:(\d+)\:(\d+) (\+\d+|UTC|GMT)$/;
      parseDateMonths = {
        Jan: 0,
        Feb: 1,
        Mar: 2,
        Apr: 3,
        May: 4,
        Jun: 5,
        Jul: 6,
        Aug: 7,
        Sep: 8,
        Oct: 9,
        Nov: 10,
        Dec: 11
      };
      return Dropbox.Util.parseDate = function(dateString) {
        var match;
        if (!(match = parseDateRe.exec(dateString))) {
          return NaN;
        }
        return new Date(Date.UTC(parseInt(match[3]), parseDateMonths[match[2]], parseInt(match[1]), parseInt(match[4]), parseInt(match[5]), parseInt(match[6]), 0));
      };
    })();
  }

  Dropbox.Util.countUtf8Bytes = function(s) {
    var bytes, c, i, l, ref;
    bytes = 0;
    for (i = l = 0, ref = s.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      c = s.charCodeAt(i);
      if (c <= 0x7f) {
        bytes += 1;
      } else if (c <= 0x7FF) {
        bytes += 2;
      } else if ((0xD800 <= c && c <= 0xDFFF)) {
        bytes += 2;
      } else if (c <= 0xFFFF) {
        bytes += 3;
      } else {
        assert(false);
      }
    }
    return bytes;
  };

  if (Dropbox.Env.global.XMLHttpRequest) {
    if (Dropbox.Env.global.XDomainRequest && !('withCredentials' in new XMLHttpRequest())) {
      DbxXhrRequest = XDomainRequest;
      DbxXhrIeMode = true;
      DbxXhrCanSendForms = false;
    } else {
      DbxXhrRequest = XMLHttpRequest;
      DbxXhrIeMode = false;
      DbxXhrCanSendForms = typeof FormData !== 'undefined' && navigator.userAgent.indexOf('Firefox') === -1;
    }
    DbxXhrDoesPreflight = true;
  } else {
    DbxXhrRequest = Dropbox.Env.require('xhr2');
    DbxXhrIeMode = false;
    DbxXhrCanSendForms = false;
    DbxXhrDoesPreflight = false;
  }

  if (!Dropbox.Env.global.Uint8Array) {
    DbxXhrArrayBufferView = null;
    DbxXhrWrapBlob = false;
    DbxXhrSendArrayBufferView = false;
  } else {
    if (Object.getPrototypeOf) {
      DbxXhrArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array(0))).constructor;
    } else if (Object.__proto__) {
      DbxXhrArrayBufferView = (new Uint8Array(0)).__proto__.__proto__.constructor;
    }
    if (!Dropbox.Env.global.Blob) {
      DbxXhrWrapBlob = false;
      DbxXhrSendArrayBufferView = true;
    } else {
      try {
        (function() {
          if ((new Blob([new Uint8Array(2)])).size === 2) {
            DbxXhrWrapBlob = true;
            return DbxXhrSendArrayBufferView = true;
          } else {
            DbxXhrSendArrayBufferView = false;
            return DbxXhrWrapBlob = (new Blob([new ArrayBuffer(2)])).size === 2;
          }
        })();
      } catch (_error) {
        DbxXhrSendArrayBufferView = false;
        DbxXhrWrapBlob = false;
        if (Dropbox.Env.global.WebKitBlobBuilder) {
          if (navigator.userAgent.indexOf('Android') !== -1) {
            DbxXhrCanSendForms = false;
          }
        }
      }
      if (DbxXhrArrayBufferView === Object) {
        DbxXhrSendArrayBufferView = false;
      }
    }
  }

  Dropbox.Util.Xhr = (function() {
    Xhr.Request = DbxXhrRequest;

    Xhr.ieXdr = DbxXhrIeMode;

    Xhr.canSendForms = DbxXhrCanSendForms;

    Xhr.doesPreflight = DbxXhrDoesPreflight;

    Xhr.ArrayBufferView = DbxXhrArrayBufferView;

    Xhr.sendArrayBufferView = DbxXhrSendArrayBufferView;

    Xhr.wrapBlob = DbxXhrWrapBlob;

    function Xhr(method1, baseUrl) {
      this.method = method1;
      this.isGet = this.method === 'GET';
      this.url = baseUrl;
      this.wantHeaders = false;
      this.headers = {};
      this.params = null;
      this.body = null;
      this.preflight = !(this.isGet || (this.method === 'POST'));
      this.signed = false;
      this.completed = false;
      this.responseType = null;
      this.callback = null;
      this.xhr = null;
      this.onError = null;
    }

    Xhr.prototype.xhr = null;

    Xhr.prototype.onError = null;

    Xhr.prototype.setParams = function(params) {
      if (this.signed) {
        throw new Error('setParams called after addOauthParams or addOauthHeader');
      }
      if (this.params) {
        throw new Error('setParams cannot be called twice');
      }
      this.params = params;
      return this;
    };

    Xhr.prototype.setCallback = function(callback1) {
      this.callback = callback1;
      return this;
    };

    Xhr.prototype.signWithOauth = function(oauth, cacheFriendly) {
      if (Dropbox.Util.Xhr.ieXdr) {
        return this.addOauthParams(oauth);
      } else if (this.preflight || !Dropbox.Util.Xhr.doesPreflight) {
        return this.addOauthHeader(oauth);
      } else {
        if (this.isGet && cacheFriendly) {
          return this.addOauthHeader(oauth);
        } else {
          return this.addOauthParams(oauth);
        }
      }
    };

    Xhr.prototype.addOauthParams = function(oauth) {
      if (this.signed) {
        throw new Error('Request already has an OAuth signature');
      }
      this.params || (this.params = {});
      oauth.addAuthParams(this.method, this.url, this.params);
      this.signed = true;
      return this;
    };

    Xhr.prototype.addOauthHeader = function(oauth) {
      if (this.signed) {
        throw new Error('Request already has an OAuth signature');
      }
      this.params || (this.params = {});
      this.signed = true;
      return this.setHeader('Authorization', oauth.authHeader(this.method, this.url, this.params));
    };

    Xhr.prototype.setBody = function(body) {
      if (this.isGet) {
        throw new Error('setBody cannot be called on GET requests');
      }
      if (this.body !== null) {
        throw new Error('Request already has a body');
      }
      if (typeof body === 'string') {

      } else if ((typeof FormData !== 'undefined') && (body instanceof FormData)) {

      } else {
        this.headers['Content-Type'] = 'application/octet-stream';
        this.preflight = true;
      }
      this.body = body;
      return this;
    };

    Xhr.prototype.setResponseType = function(responseType1) {
      this.responseType = responseType1;
      return this;
    };

    Xhr.prototype.setHeader = function(headerName, value) {
      var oldValue;
      if (this.headers[headerName]) {
        oldValue = this.headers[headerName];
        throw new Error("HTTP header " + headerName + " already set to " + oldValue);
      }
      if (headerName === 'Content-Type') {
        throw new Error('Content-Type is automatically computed based on setBody');
      }
      this.preflight = true;
      this.headers[headerName] = value;
      return this;
    };

    Xhr.prototype.reportResponseHeaders = function() {
      return this.wantHeaders = true;
    };

    Xhr.prototype.setFileField = function(fieldName, fileName, fileData, contentType) {
      var blob, blobError, boundary, builder, useFormData;
      if (this.body !== null) {
        throw new Error('Request already has a body');
      }
      if (this.isGet) {
        throw new Error('setFileField cannot be called on GET requests');
      }
      if (typeof fileData === 'object') {
        if (typeof ArrayBuffer !== 'undefined') {
          if (fileData instanceof ArrayBuffer) {
            if (Dropbox.Util.Xhr.sendArrayBufferView) {
              fileData = new Uint8Array(fileData);
            }
          } else {
            if (!Dropbox.Util.Xhr.sendArrayBufferView && fileData.byteOffset === 0 && fileData.buffer instanceof ArrayBuffer) {
              fileData = fileData.buffer;
            }
          }
        }
        contentType || (contentType = 'application/octet-stream');
        try {
          fileData = new Blob([fileData], {
            type: contentType
          });
        } catch (_error) {
          blobError = _error;
          if (window.WebKitBlobBuilder) {
            builder = new WebKitBlobBuilder;
            builder.append(fileData);
            if (blob = builder.getBlob(contentType)) {
              fileData = blob;
            }
          }
        }
        if (typeof File !== 'undefined' && fileData instanceof File) {
          fileData = new Blob([fileData], {
            type: fileData.type
          });
        }
        useFormData = fileData instanceof Blob;
      } else {
        useFormData = false;
      }
      if (useFormData) {
        this.body = new FormData();
        return this.body.append(fieldName, fileData, fileName);
      } else {
        contentType || (contentType = 'application/octet-stream');
        boundary = this.multipartBoundary();
        this.headers['Content-Type'] = "multipart/form-data; boundary=" + boundary;
        return this.body = ['--', boundary, "\r\n", 'Content-Disposition: form-data; name="', fieldName, '"; filename="', fileName, "\"\r\n", 'Content-Type: ', contentType, "\r\n", "Content-Transfer-Encoding: binary\r\n\r\n", fileData, "\r\n", '--', boundary, '--', "\r\n"].join('');
      }
    };

    Xhr.prototype.multipartBoundary = function() {
      return [Date.now().toString(36), Math.random().toString(36)].join('----');
    };

    Xhr.prototype.paramsToUrl = function() {
      var queryString;
      if (this.params) {
        queryString = Dropbox.Util.Xhr.urlEncode(this.params);
        if (queryString.length !== 0) {
          this.url = [this.url, '?', queryString].join('');
        }
        this.params = null;
      }
      return this;
    };

    Xhr.prototype.paramsToBody = function() {
      if (this.params) {
        if (this.body !== null) {
          throw new Error('Request already has a body');
        }
        if (this.isGet) {
          throw new Error('paramsToBody cannot be called on GET requests');
        }
        this.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        this.body = Dropbox.Util.Xhr.urlEncode(this.params);
        this.params = null;
      }
      return this;
    };

    Xhr.prototype.prepare = function() {
      var header, ieXdr, ref, value;
      ieXdr = Dropbox.Util.Xhr.ieXdr;
      if (this.isGet || this.body !== null || ieXdr) {
        this.paramsToUrl();
        if (this.body !== null && typeof this.body === 'string') {
          this.headers['Content-Type'] = 'text/plain; charset=utf8';
        }
      } else {
        this.paramsToBody();
      }
      this.xhr = new Dropbox.Util.Xhr.Request();
      if (ieXdr) {
        this.xhr.onload = (function(_this) {
          return function() {
            return _this.onXdrLoad();
          };
        })(this);
        this.xhr.onerror = (function(_this) {
          return function() {
            return _this.onXdrError();
          };
        })(this);
        this.xhr.ontimeout = (function(_this) {
          return function() {
            return _this.onXdrError();
          };
        })(this);
        this.xhr.onprogress = function() {};
      } else {
        this.xhr.onreadystatechange = (function(_this) {
          return function() {
            return _this.onReadyStateChange();
          };
        })(this);
      }
      this.xhr.open(this.method, this.url, true);
      if (!ieXdr) {
        ref = this.headers;
        for (header in ref) {
          if (!hasProp.call(ref, header)) continue;
          value = ref[header];
          this.xhr.setRequestHeader(header, value);
        }
      }
      if (this.responseType) {
        if (this.responseType === 'b') {
          if (this.xhr.overrideMimeType) {
            this.xhr.overrideMimeType('text/plain; charset=x-user-defined');
          }
        } else {
          this.xhr.responseType = this.responseType;
        }
      }
      return this;
    };

    Xhr.prototype.send = function(callback) {
      var body, xhrError;
      this.callback = callback || this.callback;
      if (this.body !== null) {
        body = this.body;
        if (Dropbox.Util.Xhr.sendArrayBufferView) {
          if (body instanceof ArrayBuffer) {
            body = new Uint8Array(body);
          }
        } else {
          if (body.byteOffset === 0 && body.buffer instanceof ArrayBuffer) {
            body = body.buffer;
          }
        }
        try {
          this.xhr.send(body);
        } catch (_error) {
          xhrError = _error;
          if (!Dropbox.Util.Xhr.sendArrayBufferView && Dropbox.Util.Xhr.wrapBlob) {
            body = new Blob([body], {
              type: 'application/octet-stream'
            });
            this.xhr.send(body);
          } else {
            throw xhrError;
          }
        }
      } else {
        this.xhr.send();
      }
      return this;
    };

    Xhr.urlEncode = function(object) {
      var chunks, key, value;
      chunks = [];
      for (key in object) {
        value = object[key];
        chunks.push(this.urlEncodeValue(key) + '=' + this.urlEncodeValue(value));
      }
      return chunks.sort().join('&');
    };

    Xhr.urlEncodeValue = function(object) {
      return encodeURIComponent(object.toString()).replace(/\!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    };

    Xhr.urlDecode = function(string) {
      var kvp, l, len1, ref, result, token;
      result = {};
      ref = string.split('&');
      for (l = 0, len1 = ref.length; l < len1; l++) {
        token = ref[l];
        kvp = token.split('=');
        result[decodeURIComponent(kvp[0])] = decodeURIComponent(kvp[1]);
      }
      return result;
    };

    Xhr.prototype.onReadyStateChange = function() {
      var allHeaders, apiError, bytes, contentType, dirtyText, duplicateIndex, headers, i, jsonError, l, metadata, metadataJson, offset, ref, text;
      if (this.xhr.readyState !== 4) {
        return true;
      }
      if (this.completed) {
        return true;
      }
      this.completed = true;
      if (this.xhr.status < 200 || this.xhr.status >= 300) {
        apiError = new Dropbox.ApiError(this.xhr, this.method, this.url);
        if (this.onError) {
          this.onError(apiError, this.callback);
        } else {
          this.callback(apiError);
        }
        return true;
      }
      if (this.wantHeaders) {
        allHeaders = this.xhr.getAllResponseHeaders();
        if (allHeaders) {
          headers = Dropbox.Util.Xhr.parseResponseHeaders(allHeaders);
        } else {
          headers = this.guessResponseHeaders();
        }
        metadataJson = headers['x-dropbox-metadata'];
      } else {
        headers = void 0;
        metadataJson = this.xhr.getResponseHeader('x-dropbox-metadata');
      }
      if (metadataJson != null ? metadataJson.length : void 0) {
        try {
          metadata = JSON.parse(metadataJson);
        } catch (_error) {
          jsonError = _error;
          duplicateIndex = metadataJson.search(/\}\,\s*\{/);
          if (duplicateIndex !== -1) {
            try {
              metadataJson = metadataJson.substring(0, duplicateIndex + 1);
              metadata = JSON.parse(metadataJson);
            } catch (_error) {
              jsonError = _error;
              metadata = void 0;
            }
          } else {
            metadata = void 0;
          }
        }
      } else {
        metadata = void 0;
      }
      if (this.responseType) {
        if (this.responseType === 'b') {
          dirtyText = this.xhr.responseText != null ? this.xhr.responseText : this.xhr.response;
          bytes = [];
          for (i = l = 0, ref = dirtyText.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
            bytes.push(String.fromCharCode(dirtyText.charCodeAt(i) & 0xFF));
          }
          text = bytes.join('');
          this.callback(null, text, metadata, headers);
        } else {
          this.callback(null, this.xhr.response, metadata, headers);
        }
        return true;
      }
      text = this.xhr.responseText != null ? this.xhr.responseText : this.xhr.response;
      contentType = this.xhr.getResponseHeader('Content-Type');
      if (contentType) {
        offset = contentType.indexOf(';');
        if (offset !== -1) {
          contentType = contentType.substring(0, offset);
        }
      }
      switch (contentType) {
        case 'application/x-www-form-urlencoded':
          this.callback(null, Dropbox.Util.Xhr.urlDecode(text), metadata, headers);
          break;
        case 'application/json':
        case 'text/javascript':
          this.callback(null, JSON.parse(text), metadata, headers);
          break;
        default:
          this.callback(null, text, metadata, headers);
      }
      return true;
    };

    Xhr.parseResponseHeaders = function(allHeaders) {
      var colonIndex, headerLines, headers, l, len1, line, name, value;
      headers = {};
      headerLines = allHeaders.split("\n");
      for (l = 0, len1 = headerLines.length; l < len1; l++) {
        line = headerLines[l];
        colonIndex = line.indexOf(':');
        name = line.substring(0, colonIndex).trim().toLowerCase();
        value = line.substring(colonIndex + 1).trim();
        headers[name] = value;
      }
      return headers;
    };

    Xhr.prototype.guessResponseHeaders = function() {
      var headers, l, len1, name, ref, value;
      headers = {};
      ref = ['cache-control', 'content-language', 'content-range', 'content-type', 'expires', 'last-modified', 'pragma', 'x-dropbox-metadata'];
      for (l = 0, len1 = ref.length; l < len1; l++) {
        name = ref[l];
        value = this.xhr.getResponseHeader(name);
        if (value) {
          headers[name] = value;
        }
      }
      return headers;
    };

    Xhr.prototype.onXdrLoad = function() {
      var headers, metadata, text;
      if (this.completed) {
        return true;
      }
      this.completed = true;
      text = this.xhr.responseText;
      if (this.wantHeaders) {
        headers = {
          'content-type': this.xhr.contentType
        };
      } else {
        headers = void 0;
      }
      metadata = void 0;
      if (this.responseType) {
        this.callback(null, text, metadata, headers);
        return true;
      }
      switch (this.xhr.contentType) {
        case 'application/x-www-form-urlencoded':
          this.callback(null, Dropbox.Util.Xhr.urlDecode(text), metadata, headers);
          break;
        case 'application/json':
        case 'text/javascript':
          this.callback(null, JSON.parse(text), metadata, headers);
          break;
        default:
          this.callback(null, text, metadata, headers);
      }
      return true;
    };

    Xhr.prototype.onXdrError = function() {
      var apiError;
      if (this.completed) {
        return true;
      }
      this.completed = true;
      apiError = new Dropbox.ApiError(this.xhr, this.method, this.url);
      if (this.onError) {
        this.onError(apiError, this.callback);
      } else {
        this.callback(apiError);
      }
      return true;
    };

    return Xhr;

  })();

  USER_AGENT_PARAM = 'X-Dropbox-User-Agent';

  REQUEST_ID_HEADER = 'X-Dropbox-Request-Id';

  Dropbox.DatastoresClient = {
    _dispatchDatastoreXhr: function(method, url, params, responseType, options, callback) {
      var cb, reqId, xhr;
      xhr = new Dropbox.Util.Xhr(method, url);
      if (options.setRequestId) {
        reqId = 'xxxxxxxxxxxxxxxx'.replace(/x/g, function() {
          return (Math.floor(Math.random() * 16)).toString(16);
        });
        xhr.setHeader(REQUEST_ID_HEADER, reqId);
      }
      assert(params[USER_AGENT_PARAM] == null);
      params = impl.clone(params);
      params[USER_AGENT_PARAM] = "dropbox-js-datastore-sdk/" + DROPBOX_JS_VERSION;
      xhr.setParams(params);
      xhr.signWithOauth(this._oauth, false);
      cb = function(error, data) {
        if (error != null) {
          return callback(error);
        }
        return callback(null, responseType.fromJSON(data));
      };
      if (options.isLongPoll) {
        this._dispatchLongPollXhr(xhr, cb);
      } else {
        this._dispatchXhr(xhr, cb);
      }
      return xhr;
    },
    _listDatastores: function(callback) {
      return this._dispatchDatastoreXhr('GET', this._urls.listDbs, {}, ListDatastoresResponse, {}, callback);
    },
    _getOrCreateDatastore: function(dsid, callback) {
      return this._dispatchDatastoreXhr('POST', this._urls.getOrCreateDb, {
        dsid: dsid
      }, CreateDatastoreResponse, {}, callback);
    },
    _createDatastore: function(dsid, key, callback) {
      return this._dispatchDatastoreXhr('POST', this._urls.createDb, {
        dsid: dsid,
        key: key
      }, CreateDatastoreResponse, {}, callback);
    },
    _getDatastore: function(dsid, callback) {
      return this._dispatchDatastoreXhr('GET', this._urls.getDb, {
        dsid: dsid
      }, GetDatastoreResponse, {}, callback);
    },
    _deleteDatastore: function(handle, callback) {
      return this._dispatchDatastoreXhr('POST', this._urls.deleteDb, {
        handle: handle
      }, DeleteDatastoreResponse, {
        setRequestId: true
      }, callback);
    },
    _putDelta: function(handle, delta, callback) {
      return this._dispatchDatastoreXhr('POST', this._urls.putDelta, {
        handle: handle,
        rev: delta.rev,
        nonce: delta.nonce,
        changes: JSON.stringify(delta.changes)
      }, PutDeltaResponse, {
        setRequestId: true
      }, callback);
    },
    _getSnapshot: function(handle, callback) {
      return this._dispatchDatastoreXhr('GET', this._urls.getSnapshot, {
        handle: handle
      }, GetSnapshotResponse, {}, callback);
    },
    _datastoreAwait: function(revisionMap, db_list_token, callback) {
      return this._dispatchDatastoreXhr('POST', this._urls.datastoreAwait, {
        get_deltas: JSON.stringify({
          cursors: revisionMap
        }),
        list_datastores: JSON.stringify({
          token: db_list_token
        })
      }, AwaitResponse, {
        isLongPoll: true,
        setRequestId: true
      }, callback);
    },
    getDatastoreManager: function() {
      var on_signout;
      if (this._datastoreManager == null) {
        this._datastoreManager = new Dropbox.Datastore.DatastoreManager(this);
        on_signout = (function(_this) {
          return function() {
            if (_this.authStep === Dropbox.Client.SIGNED_OUT) {
              _this._datastoreManager.close();
              _this._datastoreManager = null;
              return _this.onAuthStepChange.removeListener(on_signout);
            }
          };
        })(this);
        this.onAuthStepChange.addListener(on_signout);
      }
      return this._datastoreManager;
    }
  };

  (function() {
    var method, method_name, ref, results1;
    ref = Dropbox.DatastoresClient;
    results1 = [];
    for (method_name in ref) {
      method = ref[method_name];
      results1.push(Dropbox.Client.prototype[method_name] = method);
    }
    return results1;
  })();

}).call(this);
